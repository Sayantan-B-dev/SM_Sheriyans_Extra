# `src/app.js`

### CART SERVICE BOOTSTRAP ALGORITHM

```
→ import express
→ import cookie-parser
→ import cartRoutes

→ create express application instance

→ enable JSON body parsing
→ enable cookie parsing

→ define GET /
   → return 200
   → respond with "Cart service is running"

→ mount cartRoutes at /api/cart

→ export app instance
```

---

# `src/db/db.js`

### DATABASE CONNECTION ALGORITHM

```
→ import mongoose

→ define connectDB function
   → attempt connection using MONGO_URI
   → if connection succeeds:
       → log success message
   → if connection fails:
       → log error
       → do not crash service

→ export connectDB
```

---

# `src/models/cart.model.js`

### CART SCHEMA DESIGN ALGORITHM

```
→ define cart schema with fields:
   → user:
       → ObjectId
       → required
   → items: array of objects
       → productId:
           → ObjectId
           → required
       → quantity:
           → number
           → required
           → minimum value = 1

→ enable timestamps (createdAt, updatedAt)

→ export cart model
```

---

# `src/middlewares/auth.middleware.js`

### USER AUTHENTICATION & AUTHORIZATION ALGORITHM

```
→ accept allowed roles (default: ['user'])

→ return middleware function

→ extract JWT token from:
   → cookie token OR
   → Authorization header (Bearer token)

→ if token missing:
   → return 401 Unauthorized

→ verify token using JWT_SECRET
   → if invalid:
       → return 401 Unauthorized

→ check decoded role against allowed roles
   → if role not allowed:
       → return 403 Forbidden

→ attach decoded user object to req.user

→ call next()
```

---

# `src/middlewares/validation.middleware.js`

### VALIDATION RESULT HANDLING ALGORITHM

```
→ collect validation results from request

→ if validation errors exist:
   → return 400
   → respond with error list

→ else:
   → call next()
```

---

### ADD ITEM TO CART VALIDATION ALGORITHM

```
→ validate productId:
   → must be string
   → must be valid MongoDB ObjectId

→ validate qty:
   → must be integer
   → must be greater than 0

→ if any validation fails:
   → return 400

→ else:
   → proceed to controller
```

---

### UPDATE CART ITEM VALIDATION ALGORITHM

```
→ validate productId from URL param:
   → must be string
   → must be valid MongoDB ObjectId

→ validate qty:
   → must be integer
   → must be greater than 0

→ if any validation fails:
   → return 400

→ else:
   → proceed to controller
```

---

# `src/routes/cart.routes.js`

### CART ROUTE REGISTRATION ALGORITHM

```
→ create express router

→ GET /api/cart
   → authenticate user role
   → call getCart controller

→ POST /api/cart/items
   → validate request body
   → authenticate user role
   → call addItemToCart controller

→ PATCH /api/cart/items/:productId
   → validate route params and body
   → authenticate user role
   → call updateItemQuantity controller

→ export router
```

---

# `src/controllers/cart.controller.js`

---

### GET CART ALGORITHM

```
→ extract authenticated user from req.user

→ find cart where:
   → cart.user == user.id

→ if cart does not exist:
   → create new cart with:
       → user = user.id
       → items = empty array
   → save cart

→ calculate totals:
   → itemCount = number of distinct items
   → totalQuantity = sum of quantities of all items

→ return 200 with:
   → cart data
   → totals object
```

---

### ADD ITEM TO CART ALGORITHM

```
→ extract productId and qty from req.body
→ extract user from req.user

→ find cart for user

→ if cart does not exist:
   → create new cart with empty items array

→ check if product already exists in cart:
   → compare productId strings

→ if product exists:
   → increase existing item quantity by qty
→ else:
   → push new item with:
       → productId
       → quantity = qty

→ save cart

→ return 200 with:
   → success message
   → updated cart
```

---

### UPDATE CART ITEM QUANTITY ALGORITHM

```
→ extract productId from req.params
→ extract qty from req.body
→ extract user from req.user

→ find cart by user.id

→ if cart does not exist:
   → return 404 Cart not found

→ find item in cart where:
   → item.productId == productId

→ if item not found:
   → return 404 Item not found

→ update item.quantity = qty

→ save cart

→ return 200 with:
   → success message
   → updated cart
```

---

## ✅ CART MICROSERVICE GUARANTEES

* One cart per user
* Cart auto-created on first access
* Quantity always ≥ 1
* Duplicate products are merged, not duplicated
* Stateless authentication via JWT
* Validation enforced before business logic

---


# `tests/setup/globalSetup.js`

### GLOBAL TEST ENVIRONMENT SETUP ALGORITHM

```
→ set JWT_SECRET environment variable if not already set
→ ensure all tests use the same JWT secret
→ reserve hook for future global cleanup
```

---

# `tests/cart.getCart.test.js`

### TEST SUITE: GET CART (GET /api/cart)

---

### CART MODEL MOCKING ALGORITHM

```
→ replace real cart model with in-memory mock
→ store carts in a Map keyed by userId
→ override:
   → findOne(user)
   → save()
→ expose helper methods:
   → __reset() to clear state
```

---

### BEFORE EACH TEST ALGORITHM

```
→ reset mocked cart storage
```

---

### TEST: RETURN CART WITH ITEMS AND TOTALS

```
→ generate userId and JWT token with role = user

→ add first item using POST /api/cart/items
   → product A, qty = 2

→ add second item using POST /api/cart/items
   → product B, qty = 3

→ call GET /api/cart with Authorization token

→ expect:
   → status = 200
   → cart.items length = 2
   → totals.itemCount = 2
   → totals.totalQuantity = 5
```

---

### TEST: RETURN EMPTY CART WHEN NONE EXISTS

```
→ generate user JWT token

→ call GET /api/cart without seeding cart

→ expect:
   → status = 200
   → cart.items length = 0
   → totals.itemCount = 0
   → totals.totalQuantity = 0
```

---

### TEST: UNAUTHORIZED WHEN NO TOKEN

```
→ call GET /api/cart without Authorization header

→ expect status = 401
```

---

### TEST: FORBIDDEN WHEN ROLE NOT ALLOWED

```
→ generate JWT with role = admin

→ call GET /api/cart

→ expect status = 403
```

---

### TEST: UNAUTHORIZED WHEN TOKEN INVALID

```
→ call GET /api/cart with malformed token

→ expect status = 401
```

---

# `tests/cart.postItems.test.js`

### TEST SUITE: ADD ITEM TO CART (POST /api/cart/items)

---

### CART MODEL MOCKING ALGORITHM

```
→ mock cart model with in-memory Map
→ override findOne and save
→ reset storage before each test
```

---

### TEST: CREATE NEW CART AND ADD FIRST ITEM

```
→ generate userId and JWT token with role = user

→ call POST /api/cart/items
   → send productId
   → send qty = 2

→ expect:
   → status = 200
   → message = "Item added to cart"
   → cart exists
   → cart.items length = 1
   → item quantity = 2
```

---

### TEST: INCREMENT QUANTITY WHEN ITEM EXISTS

```
→ generate JWT token

→ first POST:
   → productId
   → qty = 2

→ second POST:
   → same productId
   → qty = 3

→ expect:
   → only one item in cart
   → quantity = 5
```

---

### TEST: VALIDATION ERROR – INVALID PRODUCT ID

```
→ generate JWT token

→ call POST /api/cart/items
   → productId = invalid string
   → qty = 1

→ expect:
   → status = 400
   → error list exists
   → error message includes "Invalid Product ID format"
```

---

### TEST: VALIDATION ERROR – INVALID QUANTITY

```
→ generate JWT token

→ call POST /api/cart/items
   → valid productId
   → qty = 0

→ expect:
   → status = 400
   → error list exists
   → error message includes "Quantity must be a positive integer"
```

---

### TEST: UNAUTHORIZED WHEN NO TOKEN

```
→ call POST /api/cart/items without Authorization

→ expect:
   → status = 401
   → Unauthorized message
```

---

### TEST: FORBIDDEN WHEN ROLE NOT ALLOWED

```
→ generate JWT token with role = admin

→ call POST /api/cart/items

→ expect status = 403
```

---

### TEST: UNAUTHORIZED WHEN TOKEN INVALID

```
→ call POST /api/cart/items with invalid token

→ expect status = 401
```

---

# `tests/cart.patchItems.test.js`

### TEST SUITE: UPDATE CART ITEM QUANTITY (PATCH /api/cart/items/:productId)

---

### BEFORE EACH TEST ALGORITHM

```
→ reset mocked cart storage
```

---

### TEST: UPDATE QUANTITY OF EXISTING ITEM

```
→ generate JWT token with role = user

→ seed cart using POST /api/cart/items
   → productId
   → qty = 2

→ call PATCH /api/cart/items/:productId
   → send qty = 5

→ expect:
   → status = 200
   → message = "Item updated"
   → cart item quantity = 5
```

---

### TEST: CART NOT FOUND

```
→ generate JWT token

→ call PATCH without creating cart

→ expect:
   → status = 404
   → message = "Cart not found"
```

---

### TEST: ITEM NOT FOUND IN CART

```
→ generate JWT token

→ seed cart with product A

→ call PATCH with different productId

→ expect:
   → status = 404
   → message = "Item not found"
```

---

### TEST: VALIDATION ERROR – INVALID PRODUCT ID PARAM

```
→ generate JWT token

→ call PATCH /api/cart/items/not-a-valid-id

→ expect:
   → status = 400
   → validation errors returned
```

---

### TEST: VALIDATION ERROR – INVALID QUANTITY

```
→ generate JWT token

→ seed cart with valid product

→ call PATCH with qty = 0

→ expect:
   → status = 400
   → validation errors returned
```

---

### TEST: UNAUTHORIZED WHEN NO TOKEN

```
→ call PATCH without Authorization header

→ expect status = 401
```

---

### TEST: FORBIDDEN WHEN ROLE NOT ALLOWED

```
→ generate JWT token with role = admin

→ call PATCH endpoint

→ expect status = 403
```

---

### TEST: UNAUTHORIZED WHEN TOKEN INVALID

```
→ call PATCH with malformed token

→ expect status = 401
```

---

## ✅ WHAT THIS TEST SUITE GUARANTEES

* Cart is **user-isolated**
* Cart auto-creates on first use
* Quantities are always positive integers
* Duplicate items are merged
* Strong validation before logic
* Proper auth & role en  forcement
* Predictable error codes

---
