
# Cohort online market place

---

# MERN Marketplace ‚Äì Microservices

**Stack**: MongoDB Atlas, Express/Node, React (Vite + RTK Query), RabbitMQ, Redis, Razorpay.
**Deploy**: ECR ‚Üí ECS Fargate ‚Üí ALB (path rules) ‚Üí Target Groups.
**Auth**: JWT (access+refresh, httpOnly), Google (Passport).
**Security**: Helmet, CORS, CSRF (double-submit), XSS sanitize, rate limit (Redis), RBAC.
**Observability**: Morgan + Pino, request-id, CloudWatch.

---

## 1) API Endpoints by Service (2‚Äì3 line descriptions)

> All routes are versioned implicitly as v1 via base path (e.g., /products). Add x-request-id for correlation. Validation via express-validator/zod. Descriptions note auth and idempotency when relevant.
> 

### 1.1 Auth Service

- **POST `/auth/register`** ‚Äì Create account as USER or SELLER. Validates email uniqueness, hashes password, issues refresh+access tokens. Emits `user.created`.
- **POST `/auth/login`** ‚Äì Email+password login. On success: httpOnly refresh cookie + short-lived access token in body; logs device metadata.
- **POST `/auth/logout`** ‚Äì Revokes current refresh session, clears cookies. Idempotent.
- **GET `/auth/me`** ‚Äì Returns current user (id, roles, profile). Requires valid access token.
- **PATCH `/auth/users/me`** ‚Äì Update profile fields; server-side sanitize HTML. Emits `user.updated` for analytics.
- **GET `/auth/users/me/addresses`** ‚Äì List saved addresses; mark default.
- **POST `/auth/users/me/addresses`** ‚Äì Add address (with validation for pincode/phone).
- **DELETE `/auth/users/me/addresses/:addressId`** ‚Äì Remove address.

### 1.2 Product Service

- **GET `/products`** ‚Äì Catalog listing with search (`q` text index), filters (category, price range), pagination, sort.
- **GET `/products/:id`** ‚Äì Product details, images, seller info (via populate). Cacheable by id.
- **POST `/products`** (SELLER) ‚Äì Create product; validates title/price; seeds base variant if none. Emits `product.created`.
- **PATCH `/products/:id`** (SELLER) ‚Äì Update product fields; invalidates caches; emits `product.updated`.
- **DELETE `/products/:id`** (SELLER) ‚Äì Soft delete (status=`archived`) or hard delete if no orders. Emits `product.deleted`.
- **GET `/products/seller`** (SELLER) ‚Äì seller‚Äôs product list

### 1.3 Cart Service

- **GET `/cart`** ‚Äì Fetch current cart (items, totals). Recomputes prices from Product Service to avoid tampering.
- **POST `/cart/items`** ‚Äì Add `{ productId, qty }`. Validates availability; reserves soft stock optionally.
- **PATCH `/cart/items/:productId`** ‚Äì Change quantity; removes if qty ‚â§ 0. Returns recalculated totals.
- **DELETE `/cart/items/:productId`** ‚Äì Remove line.
- **DELETE `/cart`** ‚Äì Clear cart.

### 1.4 Order Service

- **POST `/orders`** ‚Äì Create order from current cart: copies priced items, computes taxes/shipping, sets `status=pending`, reserves inventory. Emits `order.created`.
- **GET `/orders/:id`** ‚Äì Get order by id with timeline and payment summary.
- **GET `/orders/me`** ‚Äì Paginated list of the customer‚Äôs orders.
- **POST `/orders/:id/cancel`** ‚Äì Buyer-initiated cancel while `pending`/`paid` rules apply
- **PATCH `/orders/:id/address`** ‚Äì update delivery address prior to payment capture.

### 1.5 Payment Service (Razorpay)

- **POST `/payments/razorpay/order`** ‚Äì Creates Razorpay Order from server-side totals (amount, currency, receipt). Returns `{orderId, keyId}`. Idempotent per cart.
- **GET `/payments/:id`** ‚Äì Fetch payment record (status, gateway payload). RBAC: buyer or admin.
- **POST `/payments/verify`  - Verify the payment with paymentID,orderID and signature.**

### 1.7 Notification Service

- Listen to events, send emails, track delivery status

### 1.8 AI Buddy Service

- Acts like a personal shopping assistant.
- Parses natural language queries (‚ÄúFind me red sneakers under ‚Çπ2000‚Äù) ‚Üí queries Product Service.
- Can also create a Cart on behalf of the user.

### 1.9 Seller Dashboard (3)

- GET /seller/dashboard/metrics ‚Üí Sales, revenue, top products.
- GET /seller/dashboard/orders ‚Üí Seller‚Äôs orders.
- GET /seller/dashboard/products ‚Üí Seller‚Äôs product inventory & low stock alerts.

---

# **Entities & Schemas**

## **1. User Entity**

Represents an application user (customer or admin).

```jsx
{
  "userId": "string (UUID)",
  "name": "string",
  "email": "string (unique)",
  "passwordHash": "string",
  "role": "enum: ['customer', 'admin']",
  "address": [
    {
      "addressId": "string (UUID)",
      "street": "string",
      "city": "string",
      "state": "string",
      "country": "string",
      "zipCode": "string",
      "isDefault": "boolean"
    }
  ],
  "createdAt": "date",
  "updatedAt": "date"
}
```

---

## **2. Product Entity**

Represents products available in the store.

```jsx
{
  "productId": "string (UUID)",
  "name": "string",
  "description": "string",
  "price": "number",
  "category": "string",
  "stock": "number",
  "images": ["string (URL)"],
  "createdAt": "date",
  "updatedAt": "date"
}
```

---

## **3. Cart Entity**

Represents a user‚Äôs shopping cart.

```jsx
{
  "cartId": "string (UUID)",
  "userId": "string (FK ‚Üí User.userId)",
  "items": [
    {
      "productId": "string (FK ‚Üí Product.productId)",
      "quantity": "number",
    }
  ],
  "totalAmount": "number",
  "updatedAt": "date"
}
```

---

## **4. Order Entity**

Represents placed orders.

```jsx
{
  "orderId": "string (UUID)",
  "userId": "string (FK ‚Üí User.userId)",
  "items": [
    {
      "productId": "string (FK ‚Üí Product.productId)",
      "quantity": "number",
      "price": "number"
    }
  ],
  "totalAmount": "number",
  "status": "enum: ['pending', 'confirmed', 'shipped', 'delivered', 'cancelled']",
  "shippingAddress": {
    "street": "string",
    "city": "string",
    "state": "string",
    "country": "string",
    "zipCode": "string"
  },
  "createdAt": "date",
  "updatedAt": "date"
}
```

---

## **5. Payment Entity**

Tracks payment transactions.

```jsx
{
  "paymentId": "string (UUID)",
  "orderId": "string (FK ‚Üí Order.orderId)",
  "userId": "string (FK ‚Üí User.userId)",
  "amount": "number",
  "method": "enum: ['credit_card', 'debit_card', 'upi', 'paypal', 'cod']",
  "status": "enum: ['pending', 'completed', 'failed', 'refunded']",
  "transactionId": "string",
  "createdAt": "date"
}
```

---

## **6. Notification Entity**

Stores user notifications (email, SMS, in-app).

```jsx
{
  "notificationId": "string (UUID)",
  "userId": "string (FK ‚Üí User.userId)",
  "type": "enum: ['email', 'sms', 'push']",
  "message": "string",
  "status": "enum: ['pending', 'sent', 'failed']",
  "createdAt": "date"
}
```

---

## **7. Review Entity**

(Optional but common in e-commerce).

```jsx
{
  "reviewId": "string (UUID)",
  "productId": "string (FK ‚Üí Product.productId)",
  "userId": "string (FK ‚Üí User.userId)",
  "rating": "number (1-5)",
  "comment": "string",
  "createdAt": "date"
}
```

---

# **Final Entity Count**

- **User**
- **Product**
- **Cart**
- **Order**
- **Payment**
- **Notification**

---

# **Service‚ÄìEntity Mapping Table**

| **Service** | **Entities Owned** | **Responsibilities** | **Dependencies** | **RabbitMQ Events** |
| --- | --- | --- | --- | --- |
| **Auth/User Service** | User | Register/login, issue tokens, manage profiles & addresses, emit USER_CREATED/UPDATED | Needed by all services (for auth) | Emits user.created, user.updated |
| **Product Service** | Product (and optional Review) | CRUD products, manage stock, serve product data to Cart/Order, emit PRODUCT_CREATED/UPDATED/DELETED | Cart, Order, Review Service | Emits product.created, product.updated |
| **Cart Service** | Cart | Add/remove items, validate stock/price, compute totals, maintain one cart per user | Product Service (for price/stock) | Subscribes to product.updated (optional)
 |
| **Order Service** | Order | Create/manage orders, track lifecycle, reserve inventory, emit ORDER_CREATED/UPDATED | Cart, Payment, Notification | Emits order.created, order.cancelled |
| **Payment Service** | Payment | Handle Razorpay/Stripe integration, verify payments, emit PAYMENT_SUCCESS/FAILED | Order, Notification | Emits payment.success, payment.failed |
| **Notification Service** | Notification | Listen to events, send emails/SMS/push, track delivery status | User, Order, Payment | Subscribes to all major events (order.created, payment.success, etc.) |
| **Seller Dashboard Service**
 | Aggregated seller metrics & insights | /seller/dashboard/metrics, /seller/dashboard/orders, /seller/dashboard/products
 |  | Subscribes to order.created, payment.success, product.updated
 |

---
Displaying Cohort online market place .md.




# **Microservice Architecture: Communication Patterns**  
*Synchronous vs Asynchronous Connections in Distributed Systems*

---

## **1. Service Overview & Responsibilities**

### **Our Microservices Ecosystem:**
1. **Auth Service** - User authentication, authorization, JWT tokens
2. **Cart Service** - Shopping cart management
3. **Order Service** - Order processing, fulfillment
4. **Notification Service** - Email, SMS, push notifications
5. **Payment Service** - Payment gateway integration
6. **Seller Service** - Seller/supplier management
7. **AI Buddy Service** - Recommendations, chatbots, analytics

---

## **2. Synchronous Communication (API Calls)**

### **When to Use:**
- **Immediate response needed** (user waiting)
- **Data consistency critical** (real-time validation)
- **Simple request-response** patterns
- **Small payloads**

### **Example Synchronous Flows:**

#### **User Login Flow:**
```javascript
// Synchronous API call chain
Frontend ‚Üí Auth Service (login) ‚Üí Returns JWT token
Frontend ‚Üí Cart Service (get cart) ‚Üí Requires valid token
Frontend ‚Üí AI Buddy Service (recommendations) ‚Üí Uses user data
```

#### **Checkout Flow:**
```javascript
// Step-by-step synchronous validation
1. Cart Service ‚Üí Auth Service (validate token) ‚úì
2. Cart Service ‚Üí Payment Service (validate payment method) ‚úì  
3. Cart Service ‚Üí Seller Service (check stock availability) ‚úì
4. Cart Service ‚Üí Order Service (create order) ‚úì
```

### **REST API Communication:**
```
Cart Service ‚Üí [HTTP POST] ‚Üí Order Service
Headers: Authorization: Bearer <token>
Body: { "userId": "123", "items": [...] }
Response: 201 Created with order ID
```

---

## **3. Asynchronous Communication (Message Queues)**

### **What is a Message Broker?**
A **message broker** is middleware that enables applications/services to communicate by exchanging messages. It acts as an intermediary, storing messages until they're consumed.

### **Popular Message Brokers:**
1. **RabbitMQ** - Most popular, AMQP protocol, great for complex routing
2. **Apache Kafka** - High throughput, log-based, event streaming
3. **Amazon SQS** - AWS managed, simple queue service
4. **Redis Pub/Sub** - Simple, in-memory, fast but not persistent
5. **Beanstalkd** - Simple, fast, job queue

### **Why Use Message Queues?**
1. **Decoupling**: Services don't need to know about each other
2. **Reliability**: Messages aren't lost if service is down
3. **Scalability**: Handle traffic spikes
4. **Async Processing**: Don't block main operations

### **RabbitMQ Concepts:**
```
Producer ‚Üí Exchange ‚Üí Queue ‚Üí Consumer
```
- **Exchange**: Receives messages and routes them to queues
- **Queue**: Buffer storing messages
- **Binding**: Link between exchange and queue with routing key
- **Routing Key**: Pattern for message routing

---

## **4. When to Use Which Pattern**

### **Use Synchronous (API Calls) When:**
‚úÖ **User is waiting** for immediate response  
‚úÖ **Need transaction consistency** (ACID properties)  
‚úÖ **Simple data retrieval** (GET requests)  
‚úÖ **Low latency required**  
‚úÖ **Request size is small**

**Examples:**
- User login (Auth Service)
- Add to cart (Cart Service)
- Get order status (Order Service)
- Payment authorization (Payment Service)

### **Use Asynchronous (Message Queue) When:**
‚úÖ **Long-running processes** (minutes/hours)  
‚úÖ **Multiple services need same event**  
‚úÖ **Decouple services for reliability**  
‚úÖ **Handle traffic spikes**  
‚úÖ **Event-driven architecture**

**Examples:**
- Send order confirmation email (Notification Service)
- Update inventory after purchase (Seller Service)
- Generate recommendation (AI Buddy Service)
- Payment settlement (Payment Service)

---

## **5. RabbitMQ Implementation Pattern**

### **Setup Example:**
```javascript
// Notification Service (Consumer/Subscriber)
const amqp = require('amqplib');

async function setupNotificationConsumer() {
  const connection = await amqp.connect('amqp://localhost');
  const channel = await connection.createChannel();
  
  // Declare exchange
  await channel.assertExchange('order-events', 'topic', { durable: true });
  
  // Declare queue for notification service
  const q = await channel.assertQueue('notification-queue', { durable: true });
  
  // Bind queue to exchange with routing key
  await channel.bindQueue(q.queue, 'order-events', 'order.created');
  await channel.bindQueue(q.queue, 'order-events', 'payment.completed');
  
  // Consume messages
  channel.consume(q.queue, (msg) => {
    const event = JSON.parse(msg.content.toString());
    console.log('Notification Service received:', event);
    
    // Send email/SMS based on event type
    if (event.type === 'order.created') {
      sendOrderConfirmation(event.orderId, event.userEmail);
    }
    
    channel.ack(msg); // Acknowledge message processed
  });
}
```

```javascript
// Order Service (Producer/Publisher)
async function publishOrderCreated(orderData) {
  const connection = await amqp.connect('amqp://localhost');
  const channel = await connection.createChannel();
  
  const event = {
    type: 'order.created',
    orderId: orderData.id,
    userId: orderData.userId,
    userEmail: orderData.email,
    timestamp: new Date()
  };
  
  channel.publish(
    'order-events',           // Exchange name
    'order.created',          // Routing key
    Buffer.from(JSON.stringify(event)),
    { persistent: true }      // Message survives broker restart
  );
  
  await channel.close();
  await connection.close();
}
```

---

## **6. Complete Data Flow Diagram**

```mermaid
graph TB
    %% Define Styles
    classDef frontend fill:#e8f4f8,stroke:#2980b9,stroke-width:2px
    classDef service fill:#d5f4e6,stroke:#27ae60,stroke-width:2px
    classDef broker fill:#fef9e7,stroke:#f39c12,stroke-width:2px
    classDef api fill:#ebdef0,stroke:#8e44ad,stroke-width:2px
    classDef queue fill:#fadbd8,stroke:#e74c3c,stroke-width:2px
    
    %% Frontend/User
    User[üë§ User/Browser/App] -->|1. Login Request| Auth
    
    %% Auth Service (Central)
    Auth[üîê Auth Service<br/>JWT Tokens, Auth, Users]
    
    %% Synchronous API Calls (Solid Lines)
    Auth -->|2. Returns JWT| User
    
    User -->|3. Get Cart| Cart[üõí Cart Service]
    Cart -->|4. Validate Token| Auth
    
    User -->|5. Request Recommendations| AI[ü§ñ AI Buddy Service]
    AI -->|6. Get User Profile| Auth
    
    User -->|7. Checkout| Cart
    Cart -->|8. Validate Payment Method| Payment[üí∞ Payment Service]
    Cart -->|9. Check Stock| Seller[üè™ Seller Service]
    Seller -->|10. Validate Seller| Auth
    
    Cart -->|11. Create Order| Order[üì¶ Order Service]
    Order -->|12. Validate Order| Auth
    
    %% Message Broker (RabbitMQ)
    subgraph Broker["Message Broker (RabbitMQ)"]
        Exchange[üîÑ Exchange<br/>order-events]
        
        subgraph Queues["Queues"]
            Q_Notify[üì® notification-queue]
            Q_AI[üß† ai-events-queue]
            Q_Seller[üì¶ seller-updates-queue]
            Q_Payment[üí≥ payment-settlement-queue]
        end
        
        Exchange -->|route: order.created| Q_Notify
        Exchange -->|route: order.*| Q_AI
        Exchange -->|route: order.completed| Q_Seller
        Exchange -->|route: payment.*| Q_Payment
    end
    
    %% Asynchronous Events (Dashed Lines)
    Order -.->|13. Publish: order.created| Exchange
    Payment -.->|14. Publish: payment.completed| Exchange
    
    %% Service Subscriptions
    Q_Notify -.->|15. Consume Events| Notify[üì¢ Notification Service]
    Q_AI -.->|16. Consume Events| AI
    Q_Seller -.->|17. Consume Events| Seller
    Q_Payment -.->|18. Consume Events| Payment
    
    %% Notification Flows
    Notify -->|19. Send Email| User
    Notify -->|20. Send SMS| User
    
    %% AI Service Processing
    AI -->|21. Store for ML| DB_AI[(üìä AI Database)]
    
    %% Seller Service Processing
    Seller -->|22. Update Inventory| DB_Seller[(üì¶ Inventory DB)]
    
    %% Payment Processing
    Payment -->|23. Settlement| External[üè¶ Bank/Payment Gateway]
    
    %% Database Connections
    Auth --> DB_Auth[(üë• Users DB)]
    Cart --> DB_Cart[(üõí Cart DB)]
    Order --> DB_Order[(üìã Orders DB)]
    Payment --> DB_Payment[(üí≥ Payments DB)]
    
    %% API Gateway (Optional)
    APIGateway[üö™ API Gateway] --> Auth
    APIGateway --> Cart
    APIGateway --> Order
    APIGateway --> Payment
    APIGateway --> Seller
    APIGateway --> AI
    User --> APIGateway
    
    %% Apply Styles
    class User,External frontend
    class Auth,Cart,Order,Payment,Seller,AI,Notify service
    class Broker,Exchange,Queues broker
    class APIGateway api
    class Q_Notify,Q_AI,Q_Seller,Q_Payment queue
    
    %% Legend
    subgraph Legend["Communication Types"]
        Sync[--- Synchronous (API Call)]
        Async[-.- Asynchronous (Message Queue)]
    end
```

---

## **7. Detailed Communication Examples**

### **Scenario: User Places Order**

#### **Synchronous Path (User Waits):**
```
1. User ‚Üí Cart Service: "Checkout my cart"
2. Cart Service ‚Üí Auth Service: "Validate user token" ‚úì
3. Cart Service ‚Üí Payment Service: "Authorize payment" ‚úì
4. Cart Service ‚Üí Seller Service: "Check inventory" ‚úì
5. Cart Service ‚Üí Order Service: "Create order" ‚úì
6. Order Service ‚Üí Returns: "Order #123 created successfully" ‚úì
7. Cart Service ‚Üí User: "Order placed!" (Immediate response)
```

#### **Asynchronous Path (Background Processing):**
```
1. Order Service ‚Üí RabbitMQ: Publish "order.created" event
2. RabbitMQ ‚Üí Notification Service: "Send confirmation email"
3. RabbitMQ ‚Üí AI Service: "Update user preferences"
4. RabbitMQ ‚Üí Seller Service: "Update inventory count"
5. RabbitMQ ‚Üí Payment Service: "Process settlement in background"

All these happen AFTER user gets immediate response
```

### **Scenario: New User Registration**

#### **Synchronous:**
```
1. User ‚Üí Auth Service: "Register new account"
2. Auth Service: Creates user, returns JWT token ‚úì
3. User gets immediate login access ‚úì
```

#### **Asynchronous (Triggered):**
```
1. Auth Service ‚Üí RabbitMQ: "user.registered" event
2. RabbitMQ ‚Üí Notification Service: "Send welcome email"
3. RabbitMQ ‚Üí AI Service: "Create user profile for recommendations"
4. RabbitMQ ‚Üí Cart Service: "Initialize empty cart for new user"
```

---

## **8. Service Dependencies Matrix**

| Service | Sync Dependencies | Async Subscriptions (Events) |
|---------|------------------|------------------------------|
| **Auth** | None (called by others) | None |
| **Cart** | Auth, Order, Payment | `user.registered`, `order.completed` |
| **Order** | Auth, Cart, Seller | `payment.completed`, `inventory.updated` |
| **Notification** | None | `order.*`, `payment.*`, `user.*` |
| **Payment** | Auth, Order | `order.created` |
| **Seller** | Auth | `order.created`, `order.cancelled` |
| **AI Buddy** | Auth | `user.*`, `order.*`, `payment.*` |

---

## **9. Error Handling Patterns**

### **Synchronous Errors:**
```javascript
try {
  const response = await axios.post('http://order-service/orders', data);
  return response.data;
} catch (error) {
  // Immediate feedback to user
  if (error.response?.status === 401) {
    throw new Error('Please login again');
  }
  // Retry logic or fallback
}
```

### **Asynchronous Errors (Queue):**
```javascript
// RabbitMQ: Dead Letter Exchange (DLX) pattern
channel.consume('order-queue', async (msg) => {
  try {
    await processOrder(msg);
    channel.ack(msg);
  } catch (error) {
    // Move to dead letter queue for later investigation
    channel.nack(msg, false, false);
  }
});
```

---

## **10. Choosing Between Sync & Async**

### **Decision Checklist:**

**Choose SYNC if:**
- [ ] User is waiting for result
- [ ] Operation is fast (< 2 seconds)
- [ ] Need immediate consistency
- [ ] Simple request-response
- [ ] Error handling is straightforward

**Choose ASYNC if:**
- [ ] Operation takes > 5 seconds
- [ ] Multiple services need same event
- [ ] Can tolerate eventual consistency
- [ ] Need to handle traffic spikes
- [ ] Want to decouple services

---

## **11. Performance Considerations**

### **Synchronous (Pros/Cons):**
```
‚úÖ Pros:
   - Simple to implement
   - Immediate feedback
   - Easier debugging
   
‚ùå Cons:
   - Cascading failures
   - Tight coupling
   - Timeouts under load
```

### **Asynchronous (Pros/Cons):**
```
‚úÖ Pros:
   - Better scalability
   - Loose coupling
   - Fault tolerance
   
‚ùå Cons:
   - Complexity
   - Message ordering issues
   - Debugging harder
```

---

## **12. Best Practices Summary**

1. **Start with synchronous** for critical user flows
2. **Offload to async** for background processing
3. **Use API Gateway** for routing synchronous calls
4. **Implement retry logic** for async message processing
5. **Monitor queue lengths** to prevent backlogs
6. **Use correlation IDs** to trace requests across services
7. **Implement circuit breakers** for synchronous calls
8. **Design idempotent consumers** for message queues

---

**Final Architecture Principle**: Use synchronous communication for user-facing operations that need immediate feedback. Use asynchronous messaging for background processing, notifications, and decoupling services. The combination creates a resilient, scalable system where user experience isn't blocked by background tasks.