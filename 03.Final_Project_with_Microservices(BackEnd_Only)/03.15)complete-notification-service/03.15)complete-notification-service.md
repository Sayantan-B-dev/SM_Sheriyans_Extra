# üìÅ `src/app.js`

## APPLICATION BOOTSTRAP + BROKER INIT ALGORITHM

```
APPLICATION STARTUP:
‚Üí import express()
     - express() creates an HTTP server abstraction
‚Üí import connect() from broker
     - connect(): async function to establish RabbitMQ connection
‚Üí import setListeners()
     - setListeners(): registers all queue consumers

‚Üí create app instance using express()

‚Üí call connect()
     - returns a Promise
     - .then() ensures listeners are registered only AFTER broker is ready

‚Üí call setListeners()
     - internally calls subscribeToQueue() multiple times

‚Üí expose GET "/" endpoint
     - app.get(): registers HTTP route
     - res.status(200): sets HTTP status
     - res.json(): sends JSON response

‚Üí export app
     - allows server.js to start HTTP server
```

---

# üìÅ `src/borker/borker.js`

## BROKER CONNECTION FUNCTION (`connect`) ALGORITHM

```
FUNCTION connect():
‚Üí uses async/await
     - async allows non-blocking I/O
     - await pauses execution until Promise resolves

‚Üí check if connection already exists
     - prevents multiple RabbitMQ connections

‚Üí amqplib.connect(RABBIT_URL)
     - opens TCP connection to RabbitMQ server

‚Üí createChannel()
     - channel is a lightweight virtual connection
     - all queue operations use channel

‚Üí store connection & channel in module scope
     - shared across functions

‚Üí try/catch block
     - prevents app crash on broker failure
```

---

## PUBLISH TO QUEUE FUNCTION (`publishToQueue`) ALGORITHM

```
FUNCTION publishToQueue(queueName, data):
‚Üí ensure broker connection exists
     - lazy initialization pattern

‚Üí channel.assertQueue(queueName, { durable: true })
     - creates queue if not exists
     - durable=true ensures messages survive broker restart

‚Üí JSON.stringify(data)
     - converts JS object to string

‚Üí Buffer.from()
     - RabbitMQ transmits binary data

‚Üí channel.sendToQueue()
     - fire-and-forget message publish

‚Üí logging confirms event emission
```

---

## SUBSCRIBE TO QUEUE FUNCTION (`subscribeToQueue`) ALGORITHM

```
FUNCTION subscribeToQueue(queueName, callback):
‚Üí ensure connection & channel

‚Üí assertQueue(queueName, durable=true)

‚Üí channel.consume(queueName, handler)
     - registers consumer
     - handler triggers for each message

‚Üí msg.content.toString()
     - converts buffer to string

‚Üí JSON.parse()
     - converts message back to object

‚Üí await callback(data)
     - async processing (email, DB, API, etc.)

‚Üí channel.ack(msg)
     - acknowledges successful processing
     - prevents message re-delivery
```

---

# üìÅ `src/borker/listners.js`

## LISTENER REGISTRATION FUNCTION ALGORITHM

```
SET LISTENERS FUNCTION:
‚Üí import subscribeToQueue()
‚Üí import sendEmail()

‚Üí function exports a single initializer
‚Üí multiple subscribeToQueue() calls inside
‚Üí each call:
     - binds queue to a business action
```

---

## USER CREATED LISTENER ALGORITHM

```
QUEUE: AUTH_NOTIFICATION.USER_CREATED
‚Üí subscribeToQueue()

‚Üí callback receives event payload
     - payload is user data published by Auth service

‚Üí extract fullName fields
     - handles optional lastName safely

‚Üí build HTML email template
     - template literals used for dynamic content

‚Üí sendEmail()
     - async operation
     - email is side-effect, not blocking
```

---

## PAYMENT INITIATED LISTENER ALGORITHM

```
QUEUE: PAYMENT_NOTIFICATION.PAYMENT_INITIATED
‚Üí receive order/payment metadata

‚Üí dynamic values injected:
     - username
     - amount
     - currency
     - orderId

‚Üí notify user payment is in progress
‚Üí no database mutation
‚Üí pure notification logic
```

---

## PAYMENT COMPLETED LISTENER ALGORITHM

```
QUEUE: PAYMENT_NOTIFICATION.PAYMENT_COMPLETED
‚Üí receive success event

‚Üí confirm transaction completion
‚Üí email acts as final acknowledgment
‚Üí async, idempotent, read-only operation
```

---

## PAYMENT FAILED LISTENER ALGORITHM

```
QUEUE: PAYMENT_NOTIFICATION.PAYMENT_FAILED
‚Üí receive failure payload

‚Üí construct failure notification
‚Üí encourage retry or support
‚Üí no retry logic inside listener
     (handled by producer or DLQ)
```

---

## PRODUCT CREATED LISTENER ALGORITHM

```
QUEUE: PRODUCT_NOTIFICATION.PRODUCT_CREATED
‚Üí triggered by product service

‚Üí lightweight marketing notification
‚Üí no dependency on order/payment
```

---

# üìÅ `src/email.js`

## EMAIL TRANSPORT CONFIGURATION ALGORITHM

```
EMAIL SETUP:
‚Üí nodemailer.createTransport()
     - creates SMTP client

‚Üí service: 'gmail'
     - uses Gmail SMTP

‚Üí OAuth2 authentication:
     - more secure than password
     - refreshToken enables long-lived access

‚Üí transporter.verify()
     - validates SMTP credentials at startup
     - fails fast if config is wrong
```

---

## SEND EMAIL FUNCTION (`sendEmail`) ALGORITHM

```
FUNCTION sendEmail(to, subject, text, html):
‚Üí async function

‚Üí transporter.sendMail()
     - sends email via SMTP

‚Üí from field:
     - branded sender identity

‚Üí supports:
     - text (fallback)
     - html (rich email)

‚Üí try/catch:
     - prevents email failure from crashing service

‚Üí logs messageId for traceability
```

---

# üîÅ COMPLETE EVENT-DRIVEN FLOW (WITH SYNTAX CONTEXT)

```
SERVICE EVENT ‚Üí
publishToQueue()
‚Üí RabbitMQ queue
‚Üí subscribeToQueue()
‚Üí async callback execution
‚Üí sendEmail()
‚Üí channel.ack()
```

---

## WHY THIS DESIGN IS STRONG (ARCHITECTURAL NOTES)

* ‚úî Non-blocking async I/O
* ‚úî Event-driven microservice isolation
* ‚úî Email failures don‚Äôt break core services
* ‚úî Durable queues protect data
* ‚úî Single responsibility per service

---

## 2Ô∏è‚É£ Code (unchanged)

```js
const express = require("express");
const { connect, subscribeToQueue } = require("./borker/borker");
const setListeners = require("./borker/listners");
const app = express();

connect().then(() => {
    setListeners();
})

app.get("/", (req, res) => {
    res.status(200).json({
        message: "Notification service is running"
    });
})

module.exports = app;
```

---

## 3Ô∏è‚É£ Line-by-line explanation

```js
const express = require("express");
```

* Imports Express
* Used only to expose a **health check endpoint**
* No middleware, no routes, very lightweight

---

```js
const { connect, subscribeToQueue } = require("./borker/borker");
```

* Imports RabbitMQ connection utilities
* `connect()` ‚Üí connects to CloudAMQP
* `subscribeToQueue()` ‚Üí used indirectly by listeners

---

```js
const setListeners = require("./borker/listners");
```

* Imports **all queue consumers**
* This function sets up subscriptions for:

  * Auth notifications
  * Payment notifications
  * Product notifications

---

```js
const app = express();
```

* Creates Express application instance

---

```js
connect().then(() => {
    setListeners();
})
```

**Very important flow:**

1. Connect to RabbitMQ first
2. Only after successful connection:

   * Start consuming queues

Why?

* Queue subscriptions **require an active channel**
* Prevents consuming before connection exists

This avoids **race conditions**.

---

```js
app.get("/", (req, res) => {
```

* Health check endpoint
* Used by:

  * Load balancers
  * Docker health checks
  * Monitoring tools

---

```js
res.status(200).json({
    message: "Notification service is running"
});
```

* Confirms service is alive
* Does NOT mean emails are working
* Only means server is up

---

```js
module.exports = app;
```

* Exports Express app
* Used by `server.js` or test runners

---

## 4Ô∏è‚É£ How this file fits into the system

```
Service starts
   ‚Üì
Connect to RabbitMQ
   ‚Üì
Register listeners
   ‚Üì
Wait for messages
```

This file **bootstraps the entire notification system**.

---

# üìÅ `src/borker/borker.js`

## 1Ô∏è‚É£ Responsibility of this file

This is the **RabbitMQ abstraction layer**.

It:

* Creates connection
* Creates channel
* Publishes messages
* Subscribes to queues

It does **not care** what the messages mean.

---

## 2Ô∏è‚É£ Code (unchanged)

```js
const amqplib = require('amqplib');

let channel, connection;

async function connect() {

    if (connection) return connection;

    try {
        connection = await amqplib.connect(process.env.RABBIT_URL);
        console.log('Connected to RabbitMQ');
        channel = await connection.createChannel();
    }
    catch (error) {
        console.error('Error connecting to RabbitMQ:', error);
    }

}
```

---

## 3Ô∏è‚É£ Line-by-line explanation (connect)

```js
const amqplib = require('amqplib');
```

* Official RabbitMQ client for Node.js
* Implements AMQP protocol

---

```js
let channel, connection;
```

* Stored **globally**
* Shared across entire service
* Prevents creating multiple connections

---

```js
if (connection) return connection;
```

* Prevents duplicate connections
* RabbitMQ connections are **expensive**

---

```js
connection = await amqplib.connect(process.env.RABBIT_URL);
```

* Connects using CloudAMQP URL
* Includes:

  * Username
  * Password
  * Host
  * VHost
  * TLS

---

```js
channel = await connection.createChannel();
```

* Creates logical message pipe
* All publish/consume happens via channel

---

### `publishToQueue`

```js
async function publishToQueue(queueName, data = {}) {
```

* Used by **Auth / Payment services**
* Publishes an event

---

```js
await channel.assertQueue(queueName, { durable: true });
```

* Ensures queue exists
* Durable = survives broker restart

---

```js
channel.sendToQueue(queueName, Buffer.from(JSON.stringify(data)));
```

* Serializes data
* Sends message to RabbitMQ
* Fire-and-forget

---

### `subscribeToQueue`

```js
channel.consume(queueName, async (msg) => {
```

* RabbitMQ pushes messages
* No polling
* Event-driven

---

```js
const data = JSON.parse(msg.content.toString());
```

* Deserializes message
* Converts Buffer ‚Üí JS object

---

```js
await callback(data);
```

* Executes business logic
* Example: send email

---

```js
channel.ack(msg);
```

* Acknowledges successful processing
* Removes message from queue

---

```js
module.exports = {
    connect,
    channel,
    connection,
    publishToQueue,
    subscribeToQueue
}
```

* Exposes broker utilities to all services

---

## 4Ô∏è‚É£ How this file fits

This file is the **postal system** of your backend.

All services speak **through this file**.

---

# üìÅ `src/borker/listners.js`

## 1Ô∏è‚É£ Responsibility

This file defines **what happens when messages arrive**.

It:

* Subscribes to queues
* Chooses email templates
* Sends notifications

---

## 2Ô∏è‚É£ Code (unchanged)

```js
const { subscribeToQueue } = require("./borker");
const { sendEmail } = require("../email");

module.exports = function () {

    subscribeToQueue("AUTH_NOTIFICATION.USER_CREATED", async (data) => {
```

---

## 3Ô∏è‚É£ Line-by-line explanation

```js
subscribeToQueue("AUTH_NOTIFICATION.USER_CREATED", async (data) => {
```

* Listens for new user registrations
* Triggered by Auth Service

---

```js
data.fullName.firstName
```

* Comes from Auth Service payload
* Notification Service trusts event structure

---

```js
await sendEmail(...)
```

* Delegates email sending
* Does not handle SMTP directly

---

Same pattern repeats for:

| Queue             | Purpose         |
| ----------------- | --------------- |
| PAYMENT_INITIATED | Payment started |
| PAYMENT_COMPLETED | Payment success |
| PAYMENT_FAILED    | Payment failure |
| PRODUCT_CREATED   | Product launch  |

Each listener:

* Independent
* Non-blocking
* Event-driven

---

## 4Ô∏è‚É£ How this file fits

This file is the **reaction layer**.

It turns **events ‚Üí user communication**.

---

# üìÅ `src/email.js`

## 1Ô∏è‚É£ Responsibility

This file:

* Configures Nodemailer
* Handles OAuth2
* Sends emails

Only Notification Service uses it.

---

## 2Ô∏è‚É£ Code (unchanged)

```js
const nodemailer = require('nodemailer');
```

---

## 3Ô∏è‚É£ Explanation

```js
service: 'gmail'
```

* Uses Gmail SMTP

---

```js
type: 'OAuth2'
```

* No password login
* Uses Google OAuth tokens

---

```js
refreshToken: process.env.REFRESH_TOKEN
```

* Long-lived credential
* Nodemailer auto-refreshes access tokens

---

```js
transporter.verify(...)
```

* Checks SMTP readiness
* Debug aid

---

```js
transporter.sendMail(...)
```

* Sends actual email
* Handles headers, body, encoding

---

## 4Ô∏è‚É£ How email fits in architecture

```
Auth / Payment
      ‚Üì
   RabbitMQ
      ‚Üì
 Notification Service
      ‚Üì
   Nodemailer
      ‚Üì
     Gmail
```

---

# üß† Final mental model (very important)

* **Producers**: Auth, Payment
* **Broker**: RabbitMQ
* **Consumer**: Notification Service
* **Transport**: Nodemailer
* **Auth**: OAuth2

No tight coupling.
No service-to-service calls.
Fully scalable.

---
