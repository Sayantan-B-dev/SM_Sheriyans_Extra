# Detailed Workflow Analysis & Enhanced Architecture Tree

## **Overall Application Architecture**
```
E-commerce Platform with Message-Driven Microservices
‚îú‚îÄ‚îÄ Monolithic Express App (REST API)
‚îú‚îÄ‚îÄ RabbitMQ Message Broker (Event-Driven Communication)
‚îî‚îÄ‚îÄ MongoDB Database (Primary Data Store)
```

## **Modified Detailed Folder Tree with Workflow Analysis**

```js
.
‚îú‚îÄ‚îÄ analyze.js
‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Development utility for codebase analysis
‚îÇ   ‚îú‚îÄ‚îÄ Defines:
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ walk(path) ‚Üí recursively traverses directory structure
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ analyze(dir) ‚Üí analyzes and generates folder tree
‚îÇ   ‚îú‚îÄ‚îÄ Runs (top-level):
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ traverse(process.cwd()) ‚Üí starts from current directory
‚îÇ   ‚îî‚îÄ‚îÄ Flow: Run manually to document project structure
‚îÇ
‚îú‚îÄ‚îÄ server.js [APPLICATION ENTRY POINT]
‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Bootstrap and orchestrate entire application
‚îÇ   ‚îú‚îÄ‚îÄ Imports:
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app (Express instance from src/app.js)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connectDB (Database connection from src/db/db.js)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ starts RabbitMQ listeners (from src/broker/listener.js)
‚îÇ   ‚îú‚îÄ‚îÄ Runs (top-level):
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connectDB() ‚Üí establishes MongoDB connection
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Event: "connected" ‚Üí logs success
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Event: "error" ‚Üí logs and exits process
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Starts message consumers ‚Üí broker/listener.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.listen(PORT) ‚Üí starts HTTP server
‚îÇ   ‚îî‚îÄ‚îÄ Workflow Sequence:
‚îÇ       ‚îî‚îÄ‚îÄ 1. Load env vars ‚Üí 2. Connect DB ‚Üí 3. Start listeners ‚Üí 4. Start server
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app.js [EXPRESS APPLICATION CONFIGURATION]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Central Express app setup and middleware configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Exports: default Express app instance
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Configuration Flow:
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 1. Creates Express instance
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2. Adds global middlewares:
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ express.json() ‚Üí parses JSON bodies
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ express.urlencoded() ‚Üí parses URL-encoded bodies
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CORS configuration
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Security headers
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 3. Registers routes:
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /api/sellers ‚Üí seller.routes.js
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ (Future routes would be added here)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 4. Adds error handling middleware
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 5. Adds 404 catch-all route
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Role: HTTP request processing pipeline configuration
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ broker/ [MESSAGE QUEUE COMMUNICATION LAYER]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Async communication between services using RabbitMQ
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ broker.js [MESSAGE BROKER CLIENT]
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Abstraction layer for RabbitMQ operations
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Defines:
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connect() ‚Üí establishes RabbitMQ connection
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Creates channel
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Asserts queues exist
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Returns connection/channel objects
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ publishToQueue(queueName, message) ‚Üí sends messages
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Converts message to Buffer
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sends to specified queue
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Returns acknowledgment
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ subscribeToQueue(queueName, callback) ‚Üí consumes messages
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Sets up consumer
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Executes callback on message receipt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Acknowledges message processing
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Exports: default object with all broker functions
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Role: Message queue client for pub/sub pattern
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ listener.js [MESSAGE CONSUMERS/EVENT HANDLERS]
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Purpose: Reacts to messages from queues (event-driven)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Runs (top-level on server startup):
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ subscribeToQueue("ORDER_CREATED", handleOrderCreated)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trigger: New order placed
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Action: Updates seller metrics
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ May send notification
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ subscribeToQueue("PAYMENT_SUCCESS", handlePaymentSuccess)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trigger: Payment processed
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Action: Updates order status
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Updates seller revenue metrics
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ subscribeToQueue("PRODUCT_UPDATE", handleProductUpdate)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trigger: Product modified
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Action: Updates inventory/cache
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ May invalidate cache
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ subscribeToQueue("USER_REGISTERED", handleUserRegistered)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trigger: New user signs up
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Action: Sends welcome email
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Initializes user profile
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ subscribeToQueue("SELLER_METRICS_UPDATE", handleMetricsUpdate)
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Trigger: Metrics calculation needed
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Action: Recalculates seller KPIs
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Updates dashboard cache
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Role: Event-driven background job processors
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ controllers/ [REQUEST HANDLERS]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Handle HTTP requests, process business logic
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ seller.controller.js [SELLER DASHBOARD LOGIC]
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Purpose: Business logic for seller operations
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Defines:
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ getMetrics(req, res, next) ‚Üí Dashboard KPIs
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input: req.user.id (from auth middleware)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Process:
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Queries Order, Payment models
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Calculates: revenue, orders count, growth
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Aggregates data for time periods
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Output: JSON with metrics
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ May publish: "METRICS_CALCULATED" event
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ getOrders(req, res, next) ‚Üí Seller's order list
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input: req.user.id + query params (pagination/filters)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Process: Query Order model with filters
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Output: Paginated orders array
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Includes: order details, customer info
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ getProducts(req, res, next) ‚Üí Seller's product catalog
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Input: req.user.id + query params
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Process: Query Product model
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Output: Products array with inventory status
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ May include: sales data per product
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Exports: default object with all controller functions
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Role: Business logic layer between routes and models
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ db/ [DATABASE CONNECTION MANAGEMENT]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Database connectivity and configuration
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ db.js [DATABASE CONNECTOR]
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Purpose: MongoDB connection singleton
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Defines:
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ connectDB() ‚Üí establishes and manages MongoDB connection
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Uses mongoose.connect() with connection string
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Sets connection options (poolSize, retry logic)
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Handles connection events:
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ "connected" ‚Üí logs success
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ "error" ‚Üí logs and may attempt reconnect
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ "disconnected" ‚Üí logs and may attempt reconnect
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ "SIGINT" ‚Üí graceful shutdown
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Returns: Mongoose connection instance
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Exports: default connectDB function
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Role: Database connection lifecycle management
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/ [REQUEST INTERCEPTORS]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Intercept and process requests before controllers
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.middleware.js [AUTHENTICATION GUARD]
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Purpose: Protects routes, validates JWT tokens
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Defines:
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ createAuthMiddleware(requiredRole) ‚Üí factory function
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Returns: middleware function (req, res, next)
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Process:
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Extracts token from Authorization header
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Verifies JWT using secret
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Checks token expiration
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Validates user role (if requiredRole provided)
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Attaches user data to req.user
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Calls next() on success
‚îÇ   ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ Error Cases:
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ No token ‚Üí 401 Unauthorized
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Invalid token ‚Üí 403 Forbidden
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Expired token ‚Üí 401 with "Token expired"
‚îÇ   ‚îÇ       ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Insufficient role ‚Üí 403 Forbidden
‚îÇ   ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Configuration: Can be role-specific (seller, admin, etc.)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Runs: On every request to protected routes
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Role: Security layer, user context provider
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/ [DATA SCHEMAS & VALIDATION]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Define data structure, validation, and DB operations
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.model.js [ORDER SCHEMA]
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Defines order structure and relationships
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Schema Fields:
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderId: String, unique
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sellerId: ObjectId (ref: User)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ customerId: ObjectId (ref: User)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products: Array of {productId, quantity, price}
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ totalAmount: Number
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status: String enum [pending, processing, shipped, delivered, cancelled]
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ shippingAddress: Object
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timestamps: createdAt, updatedAt
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Methods: updateStatus(), calculateTotal()
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Hooks: pre-save validation, post-save events
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment.model.js [PAYMENT SCHEMA]
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Tracks payment transactions
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Schema Fields:
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ paymentId: String, unique
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orderId: ObjectId (ref: Order)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ amount: Number
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ method: String enum [card, upi, netbanking]
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status: String enum [pending, success, failed, refunded]
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transactionId: String
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timestamps
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Hooks: Updates order status on payment success
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.model.js [PRODUCT CATALOG SCHEMA]
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Purpose: Product information and inventory
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Schema Fields:
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sellerId: ObjectId (ref: User)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ name: String, required
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ description: String
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ price: Number, min: 0
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ category: String
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stock: Number, default: 0
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images: Array of URLs
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ isActive: Boolean, default: true
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timestamps
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Methods: reduceStock(), isAvailable()
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Indexes: sellerId, category, price range
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.model.js [USER/SELLER SCHEMA]
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Purpose: User authentication and profile
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Schema Fields:
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ email: String, unique, required
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ password: String (hashed), required
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ role: String enum [customer, seller, admin]
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ profile: Object (name, phone, avatar)
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ sellerProfile: Object (for sellers only)
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storeName
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ businessType
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ taxId
‚îÇ   ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rating
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ isVerified: Boolean, default: false
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ timestamps
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Methods: comparePassword(), generateAuthToken()
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Hooks: pre-save password hashing
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Virtuals: fullName, isSeller
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ routes/ [HTTP ENDPOINT MAPPING]
‚îÇ       ‚îú‚îÄ‚îÄ Purpose: Maps HTTP requests to controller functions
‚îÇ       ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ seller.routes.js [SELLER API ENDPOINTS]
‚îÇ           ‚îú‚îÄ‚îÄ Purpose: Defines seller-specific REST API routes
‚îÇ           ‚îú‚îÄ‚îÄ Route Structure:
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ GET /api/sellers/metrics
‚îÇ           ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Middleware: auth.middleware("seller")
‚îÇ           ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Handler: sellerController.getMetrics
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ GET /api/sellers/orders
‚îÇ           ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Middleware: auth.middleware("seller")
‚îÇ           ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Query Params: page, limit, status, dateFrom, dateTo
‚îÇ           ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Handler: sellerController.getOrders
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ GET /api/sellers/products
‚îÇ           ‚îÇ       ‚îú‚îÄ‚îÄ Middleware: auth.middleware("seller")
‚îÇ           ‚îÇ       ‚îú‚îÄ‚îÄ Query Params: page, limit, category, inStock
‚îÇ           ‚îÇ       ‚îî‚îÄ‚îÄ Handler: sellerController.getProducts
‚îÇ           ‚îú‚îÄ‚îÄ Exports: Express Router instance
‚îÇ           ‚îî‚îÄ‚îÄ Role: HTTP route definitions and middleware chain setup
‚îÇ
‚îî‚îÄ‚îÄ package.json [DEPENDENCIES & SCRIPTS]
    ‚îú‚îÄ‚îÄ Dependencies:
    ‚îÇ   ‚îú‚îÄ‚îÄ express: Web framework
    ‚îÇ   ‚îú‚îÄ‚îÄ mongoose: MongoDB ODM
    ‚îÇ   ‚îú‚îÄ‚îÄ amqplib: RabbitMQ client
    ‚îÇ   ‚îú‚îÄ‚îÄ jsonwebtoken: Authentication
    ‚îÇ   ‚îú‚îÄ‚îÄ bcryptjs: Password hashing
    ‚îÇ   ‚îî‚îÄ‚îÄ dotenv: Environment variables
    ‚îî‚îÄ‚îÄ Scripts:
        ‚îú‚îÄ‚îÄ "start": "node server.js"
        ‚îú‚îÄ‚îÄ "dev": "nodemon server.js"
        ‚îî‚îÄ‚îÄ "analyze": "node analyze.js"
```

## **Complete Workflow Examples**

### **Scenario 1: Seller Views Dashboard Metrics**
```
HTTP Request Flow:
1. GET /api/sellers/metrics
   ‚Üì
2. auth.middleware("seller") intercepts
   ‚îú‚îÄ‚îÄ Extracts JWT from Authorization header
   ‚îú‚îÄ‚îÄ Validates token, checks role = "seller"
   ‚îú‚îÄ‚îÄ Attaches user data to req.user
   ‚îî‚îÄ‚îÄ Calls next()
   ‚Üì
3. sellerController.getMetrics(req, res, next)
   ‚îú‚îÄ‚îÄ Extracts sellerId from req.user.id
   ‚îú‚îÄ‚îÄ Queries: Order.aggregate([sellerId, date range])
   ‚îú‚îÄ‚îÄ Queries: Payment.aggregate([sellerId, status="success"])
   ‚îú‚îÄ‚îÄ Calculates: totalRevenue, avgOrderValue, orderCount
   ‚îî‚îÄ‚îÄ Returns: JSON response with metrics
   ‚Üì
4. Response sent to client
```

### **Scenario 2: Order Processing (Event-Driven)**
```
Message Queue Flow:
1. Order Service (external) publishes: "ORDER_CREATED"
   ‚îî‚îÄ‚îÄ Message: {orderId, sellerId, amount, products}
   ‚Üì
2. broker.listener.js receives message
   ‚îú‚îÄ‚îÄ Handler: handleOrderCreated(message)
   ‚îú‚îÄ‚îÄ Updates: Seller metrics cache
   ‚îú‚îÄ‚îÄ Publishes: "SELLER_NOTIFICATION" (optional)
   ‚îî‚îÄ‚îÄ Acknowledges message processing
   ‚Üì
3. Seller dashboard updates in real-time
```

### **Scenario 3: Database Connection Lifecycle**
```
Database Flow (server startup):
1. server.js calls connectDB()
   ‚Üì
2. db.js establishes MongoDB connection
   ‚îú‚îÄ‚îÄ Event: "connected" ‚Üí console.log("MongoDB connected")
   ‚îú‚îÄ‚îÄ Event: "error" ‚Üí console.error + process.exit(1)
   ‚îî‚îÄ‚îÄ Event: "disconnected" ‚Üí attempt reconnect
   ‚Üì
3. Mongoose models available for queries
```

## **Key Design Patterns Used**

1. **Repository Pattern**: Models abstract database operations
2. **Middleware Pattern**: auth.middleware intercepts requests
3. **Factory Pattern**: createAuthMiddleware() creates configured middleware
4. **Pub/Sub Pattern**: broker.js for event-driven communication
5. **Singleton Pattern**: Database connection is shared instance
6. **MVC Pattern**: Models, Views (JSON responses), Controllers

## **Data Flow Summary**
```
External Request ‚Üí Express Router ‚Üí Auth Middleware ‚Üí Controller ‚Üí 
Model Query ‚Üí Database ‚Üí Response ‚Üí (Optional) Queue Event ‚Üí 
Listener Handler ‚Üí Database Update
```

## **Error Handling Strategy**
- Controllers: try/catch with next(error)
- Express: Global error middleware
- Database: Connection error handling
- Queue: Message acknowledgment/retry logic
- HTTP: Appropriate status codes (200, 401, 403, 404, 500)

This architecture supports scalability through:
- Async processing via message queues
- Separation of concerns (controllers, models, routes)
- Event-driven updates for real-time features
- Middleware-based authentication and validation



# üß† GLOBAL IDEA (1 line)

> HTTP services perform **business actions**, then **publish events** ‚Üí background services **react to events** ‚Üí side-effects (emails, dashboards) happen **asynchronously**.

---

# üß± COMMON BROKER (applies to ALL services)

```pseudo
GLOBAL VARIABLES:
    connection = null
    channel = null

FUNCTION CONNECT_TO_RABBITMQ():
    IF connection exists:
        RETURN connection

    TRY:
        connection = connect(RABBIT_URL)
        channel = connection.createChannel()
    CATCH error:
        log error

FUNCTION PUBLISH_EVENT(queueName, payload):
    IF channel or connection not ready:
        CONNECT_TO_RABBITMQ()

    ensure queue(queueName) exists and is durable
    serialize payload to JSON
    send payload to queue(queueName)

FUNCTION SUBSCRIBE_EVENT(queueName, handler):
    IF channel or connection not ready:
        CONNECT_TO_RABBITMQ()

    ensure queue(queueName) exists and is durable

    ON message received from queue(queueName):
        parse JSON payload
        call handler(payload)
        ACK message
```

This logic is **identical** in:

* auth
* product
* order
* payment
* notification
* seller-dashboard

Only **usage differs**, not implementation.

---

# üåê SYSTEM BOOT FLOW (ALL SERVICES)

```pseudo
ON SERVICE START:
    CONNECT_TO_RABBITMQ()

    IF service has listeners:
        REGISTER queue subscriptions
```

* Producers don‚Äôt block on consumers
* Consumers start listening immediately
* No circular dependencies

---

# üîê AUTH SERVICE ‚Äî USER REGISTRATION FLOW

```pseudo
HTTP POST /auth/register arrives

FUNCTION REGISTER_USER(request):
    validate input
    hash password
    store user in AUTH database

    PARALLEL:
        PUBLISH_EVENT("AUTH_NOTIFICATION.USER_CREATED", user_public_data)
        PUBLISH_EVENT("AUTH_SELLER_DASHBOARD.USER_CREATED", full_user)

    return HTTP 201 success
```

### Meaning

* Auth **finishes fast**
* Emails & dashboards happen later
* Auth doesn‚Äôt care *who* consumes

---

# üì¶ PRODUCT SERVICE ‚Äî CREATE PRODUCT FLOW

```pseudo
HTTP POST /product arrives

FUNCTION CREATE_PRODUCT(request):
    validate seller
    store product in PRODUCT database

    PUBLISH_EVENT("PRODUCT_SELLER_DASHBOARD.PRODUCT_CREATED", product)
    PUBLISH_EVENT("PRODUCT_NOTIFICATION.PRODUCT_CREATED", {
        email,
        productId,
        sellerId
    })

    return HTTP 201 success
```

---

# üõí ORDER SERVICE ‚Äî CREATE ORDER FLOW

```pseudo
HTTP POST /order arrives

FUNCTION CREATE_ORDER(request):
    validate user
    calculate totals
    store order in ORDER database

    PUBLISH_EVENT("ORDER_SELLER_DASHBOARD.ORDER_CREATED", order)

    return HTTP 201 success
```

---

# üí≥ PAYMENT SERVICE ‚Äî PAYMENT LIFECYCLE

### Payment Initiation

```pseudo
HTTP POST /payment/create arrives

FUNCTION CREATE_PAYMENT(request):
    create Razorpay order
    store payment with status = INITIATED

    PUBLISH_EVENT("PAYMENT_SELLER_DASHBOARD.PAYMENT_CREATED", payment)
    PUBLISH_EVENT("PAYMENT_NOTIFICATION.PAYMENT_INITIATED", email_payload)

    return payment gateway response
```

### Payment Verification

```pseudo
HTTP POST /payment/verify arrives

FUNCTION VERIFY_PAYMENT(request):
    verify Razorpay signature
    update payment status = COMPLETED

    PUBLISH_EVENT("PAYMENT_NOTIFICATION.PAYMENT_COMPLETED", email_payload)
    PUBLISH_EVENT("PAYMENT_SELLER_DASHBOARD.PAYMENT_UPDATED", payment)

    return HTTP 200 success
```

---

# üìß NOTIFICATION SERVICE ‚Äî EVENT CONSUMER

```pseudo
ON SERVICE START:
    SUBSCRIBE_EVENT("AUTH_NOTIFICATION.USER_CREATED", SEND_WELCOME_EMAIL)
    SUBSCRIBE_EVENT("PAYMENT_NOTIFICATION.PAYMENT_INITIATED", SEND_PAYMENT_STARTED_EMAIL)
    SUBSCRIBE_EVENT("PAYMENT_NOTIFICATION.PAYMENT_COMPLETED", SEND_PAYMENT_SUCCESS_EMAIL)
    SUBSCRIBE_EVENT("PAYMENT_NOTIFICATION.PAYMENT_FAILED", SEND_PAYMENT_FAILED_EMAIL)
    SUBSCRIBE_EVENT("PRODUCT_NOTIFICATION.PRODUCT_CREATED", SEND_PRODUCT_LAUNCH_EMAIL)

FUNCTION SEND_EMAIL(event):
    build HTML template
    send email
    ACK message
```

### Key point

* No HTTP endpoints
* No DB ownership
* Pure side-effect service

---

# üìä SELLER DASHBOARD ‚Äî READ MODEL (CQRS)

```pseudo
ON SERVICE START:
    SUBSCRIBE_EVENT("AUTH_SELLER_DASHBOARD.USER_CREATED", STORE_USER)
    SUBSCRIBE_EVENT("PRODUCT_SELLER_DASHBOARD.PRODUCT_CREATED", STORE_PRODUCT)
    SUBSCRIBE_EVENT("ORDER_SELLER_DASHBOARD.ORDER_CREATED", STORE_ORDER)
    SUBSCRIBE_EVENT("PAYMENT_SELLER_DASHBOARD.PAYMENT_CREATED", STORE_PAYMENT)
    SUBSCRIBE_EVENT("PAYMENT_SELLER_DASHBOARD.PAYMENT_UPDATED", UPDATE_PAYMENT)

FUNCTION STORE_* (event):
    save event data into dashboard database
```

### Purpose

* Fast reads
* No joins across services
* Eventually consistent
* Optimized for dashboards

---

# üîÅ COMPLETE SYSTEM FLOW (END-TO-END)

```pseudo
User registers
‚Üí AUTH publishes events
‚Üí Notification sends email
‚Üí Seller-dashboard stores user

Seller creates product
‚Üí PRODUCT publishes events
‚Üí Notification emails users
‚Üí Seller-dashboard stores product

Buyer places order
‚Üí ORDER publishes event
‚Üí Seller-dashboard stores order

Buyer pays
‚Üí PAYMENT publishes INITIATED
‚Üí Notification emails
‚Üí Seller-dashboard stores payment

Payment verified
‚Üí PAYMENT publishes COMPLETED
‚Üí Notification emails
‚Üí Seller-dashboard updates payment
```

---

# üß† CORE PRINCIPLES ACHIEVED

‚úî Loose coupling
‚úî Event-driven consistency
‚úî Failure isolation
‚úî Horizontal scalability
‚úî Clear ownership
‚úî Async side-effects
‚úî Production-grade CQRS

---