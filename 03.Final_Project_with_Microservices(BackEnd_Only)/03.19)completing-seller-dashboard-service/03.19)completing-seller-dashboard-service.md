# **Seller Dashboard Service - Complete Code with Detailed Explanations**

## **File: `src/app.js`**
```javascript
// Import required dependencies
const express = require('express');          // Express.js framework for building web applications
const cookieParser = require('cookie-parser'); // Middleware to parse cookies from HTTP requests
const sellerRoutes = require('./routes/seller.routes'); // Import seller-specific route definitions

// Initialize Express application instance
const app = express();

// ==================== MIDDLEWARE CONFIGURATION ====================
// Middleware functions execute in order before reaching route handlers

// 1. JSON Parsing Middleware
// - Parses incoming requests with JSON payloads
// - Automatically converts JSON request body to JavaScript object
// - Makes JSON data available in req.body
app.use(express.json());

// 2. Cookie Parser Middleware
// - Parses Cookie header and populates req.cookies with an object keyed by cookie names
// - Allows reading and setting cookies in the application
app.use(cookieParser());

// ==================== ROUTE DEFINITIONS ====================

// Health Check/Status Route
// GET / - Root endpoint to verify service is running
// Returns JSON response confirming service status
app.get('/', (req, res) => {
    res.status(200).json({ message: 'Seller Dashboard Service is running.' });
});

// Seller Dashboard API Routes
// Mounts all seller-related routes under /api/seller/dashboard prefix
// All routes defined in seller.routes.js will be accessible under this path
// Example: /api/seller/dashboard/metrics, /api/seller/dashboard/orders, etc.
app.use("/api/seller/dashboard", sellerRoutes);

// ==================== EXPORT CONFIGURATION ====================
// Export the configured Express application instance
// This allows server.js to import and start the application
module.exports = app;
```

## **File: `src/broker/broker.js`**
```javascript
// Import AMQP client library for RabbitMQ communication
// AMQP (Advanced Message Queuing Protocol) is the messaging protocol RabbitMQ uses
const amqplib = require('amqplib');

// ==================== CONNECTION MANAGEMENT VARIABLES ====================
// Module-level variables to maintain singleton connection and channel instances
// These persist across multiple function calls within the same Node.js process
let channel, connection; // channel: communication channel, connection: TCP connection to RabbitMQ

// ==================== CONNECTION ESTABLISHMENT FUNCTION ====================
/**
 * Establishes and maintains connection to RabbitMQ server
 * Implements singleton pattern to reuse existing connection
 * @returns {Promise<Object>} Returns the established connection object
 */
async function connect() {
    // Singleton pattern check: If connection already exists, return it immediately
    // Prevents creating multiple connections to RabbitMQ (resource optimization)
    if (connection) return connection;

    try {
        // Establish TCP connection to RabbitMQ server using environment variable
        // process.env.RABBIT_URL contains connection string (e.g., amqp://localhost:5672)
        connection = await amqplib.connect(process.env.RABBIT_URL);
        console.log('Connected to RabbitMQ'); // Log successful connection
        
        // Create a channel within the connection
        // Channel is a lightweight virtual connection within the main TCP connection
        // Multiple channels can be created within a single connection for parallel operations
        channel = await connection.createChannel();
    }
    catch (error) {
        // Error handling for connection failures
        // Logs error but doesn't throw - allows application to continue (graceful degradation)
        console.error('Error connecting to RabbitMQ:', error);
    }
}

// ==================== MESSAGE PUBLISHING FUNCTION ====================
/**
 * Publishes messages to a specified RabbitMQ queue
 * Implements lazy initialization pattern
 * @param {string} queueName - Name of the queue to publish to
 * @param {Object} data - Data payload to be sent (defaults to empty object)
 */
async function publishToQueue(queueName, data = {}) {
    // Lazy initialization: Only establish connection when first needed
    // Check if channel or connection doesn't exist, then connect
    if (!channel || !connection) await connect();

    // Assert/declare queue with durability configuration
    // assertQueue() is idempotent - safe to call multiple times
    // durable: true ensures queue survives RabbitMQ server restarts
    await channel.assertQueue(queueName, {
        durable: true // Messages persist even if RabbitMQ restarts
    });

    // Send message to the specified queue
    // Buffer.from() converts JavaScript object to binary buffer (required by AMQP)
    // JSON.stringify() serializes the object to JSON string
    channel.sendToQueue(queueName, Buffer.from(JSON.stringify(data)));
    
    // Log for debugging and monitoring purposes
    console.log('Message sent to queue:', queueName, data);
}

// ==================== MESSAGE CONSUMPTION FUNCTION ====================
/**
 * Subscribes to a queue and processes incoming messages asynchronously
 * @param {string} queueName - Name of the queue to subscribe to
 * @param {Function} callback - Async function to process received messages
 */
async function subscribeToQueue(queueName, callback) {
    // Lazy initialization check
    if (!channel || !connection) await connect();

    // Ensure queue exists with durability settings
    await channel.assertQueue(queueName, {
        durable: true
    });

    // Set up consumer to listen for messages on the queue
    // channel.consume() registers a callback to be executed for each incoming message
    channel.consume(queueName, async (msg) => {
        // Check if message is not null (null messages signal consumer cancellation)
        if (msg !== null) {
            // Parse the message content
            // msg.content.toString() converts Buffer back to string
            // JSON.parse() converts JSON string back to JavaScript object
            const data = JSON.parse(msg.content.toString());
            
            // Execute the provided callback with the parsed data
            // await ensures callback completes before acknowledging message
            await callback(data);
            
            // Acknowledge successful message processing
            // channel.ack(msg) tells RabbitMQ this message was processed successfully
            // Without acknowledgment, message would remain in queue and be redelivered
            channel.ack(msg);
        }
    })
    // Note: No callback provided for consumer tag - can't cancel this consumer
}

// ==================== MODULE EXPORTS ====================
// Export all broker functions and connection variables
// This creates a reusable broker module for message queue operations
module.exports = {
    connect,           // Connection management function
    channel,           // Current channel instance (for advanced operations)
    connection,        // Current connection instance (for monitoring)
    publishToQueue,    // Function to send messages to queues
    subscribeToQueue   // Function to receive and process messages
}
```

## **File: `src/broker/listener.js`**
```javascript
// Import the subscribeToQueue function from the broker module
// This function handles RabbitMQ message consumption
const { subscribeToQueue } = require("./broker")

// Import all required database models for data persistence
// Each model corresponds to a MongoDB collection in the seller-dashboard database
const userModel = require("../models/user.model")      // Seller/user information
const productModel = require("../models/product.model") // Product catalog data
const orderModel = require("../models/order.model")    // Order transaction records
const paymentModel = require("../models/payment.model") // Payment transaction records

/**
 * Event Listener Setup Function
 * Configures message consumers for different event types
 * This function is called during server startup to initialize all event listeners
 * @returns {Promise<void>} No return value, sets up event listeners
 */
module.exports = async function () {
    // ==================== USER CREATION EVENT LISTENER ====================
    /**
     * Listens for: AUTH_SELLER_DASHBOARD.USER_CREATED
     * Triggered when: A new user registers in the authentication service
     * Purpose: Sync user data to seller-dashboard database for seller-specific views
     */
    subscribeToQueue("AUTH_SELLER_DASHBOARD.USER_CREATED", async (user) => {
        // Persist user data to seller-dashboard's local MongoDB
        // Creates a denormalized copy of user data for fast queries
        await userModel.create(user)
    })

    // ==================== PRODUCT CREATION EVENT LISTENER ====================
    /**
     * Listens for: PRODUCT_SELLER_DASHBOARD.PRODUCT_CREATED
     * Triggered when: A seller creates a new product in product service
     * Purpose: Maintain product catalog in seller-dashboard for analytics
     */
    subscribeToQueue("PRODUCT_SELLER_DASHBOARD.PRODUCT_CREATED", async (product) => {
        // Store product information in local database
        // Enables fast product queries without calling external service
        await productModel.create(product)
    })

    // ==================== ORDER CREATION EVENT LISTENER ====================
    /**
     * Listens for: ORDER_SELLER_DASHBOARD.ORDER_CREATED
     * Triggered when: A customer places an order containing seller's products
     * Purpose: Track orders for sales analytics and seller dashboard
     */
    subscribeToQueue("ORDER_SELLER_DASHBOARD.ORDER_CREATED", async (order) => {
        // Store order data for seller-specific reporting
        // Contains all order details including items, pricing, and customer info
        await orderModel.create(order)
    })

    // ==================== PAYMENT CREATION EVENT LISTENER ====================
    /**
     * Listens for: PAYMENT_SELLER_DASHBOARD.PAYMENT_CREATED
     * Triggered when: A payment is initiated for an order
     * Purpose: Track payment lifecycle and revenue calculations
     */
    subscribeToQueue("PAYMENT_SELLER_DASHBOARD.PAYMENT_CREATED", async (payment) => {
        // Record payment initiation in seller-dashboard
        // Used for tracking payment status and revenue recognition
        await paymentModel.create(payment)
    })

    // ==================== PAYMENT UPDATE EVENT LISTENER ====================
    /**
     * Listens for: PAYMENT_SELLER_DASHBOARD.PAYMENT_UPDATE
     * Triggered when: Payment status changes (e.g., completed, failed)
     * Purpose: Update payment status for accurate financial reporting
     */
    subscribeToQueue("PAYMENT_SELLER_DASHBOARD.PAYMENT_UPDATE", async (payment) => {
        // Update existing payment record with new status/information
        // findOneAndUpdate finds by orderId and updates all provided fields
        await paymentModel.findOneAndUpdate(
            { orderId: payment.orderId },  // Query: Find payment by orderId
            { ...payment }                  // Update: Spread all payment properties
        )
    })
}
```

## **File: `src/controllers/seller.controller.js`**
```javascript
// Import database models for data access
// These models allow querying the seller-dashboard's local MongoDB database
const userModel = require("../models/user.model")      // For seller/user information
const productModel = require("../models/product.model") // For product catalog queries
const orderModel = require("../models/order.model")    // For order history and analytics
const paymentModel = require("../models/payment.model") // For payment and revenue data

// ==================== DASHBOARD METRICS CONTROLLER ====================
/**
 * GET /api/seller/dashboard/metrics
 * Controller for fetching seller performance metrics and analytics
 * @param {Object} req - Express request object containing authenticated user data
 * @param {Object} res - Express response object for sending HTTP response
 * @returns {Object} JSON response containing sales metrics
 */
async function getMetrics(req, res) {
    try {
        // Extract authenticated seller information from request
        // req.user is populated by auth middleware with decoded JWT token data
        const seller = req.user;

        // STEP 1: Fetch all products belonging to this seller
        // Queries productModel for documents where seller field matches seller._id
        // Returns array of product objects this seller owns/created
        const products = await productModel.find({ seller: seller._id });
        
        // Extract only product IDs from the product objects
        // Creates array of MongoDB ObjectIds for use in subsequent queries
        const productIds = products.map(p => p._id);

        // STEP 2: Find all orders containing this seller's products
        // Complex query that:
        // 1. Uses $in operator to match orders containing any of seller's products
        // 2. Filters by order status to only include confirmed, shipped, or delivered orders
        // 3. Excludes pending or cancelled orders from metrics calculation
        const orders = await orderModel.find({
            'items.product': { $in: productIds }, // Orders containing seller's products
            status: { $in: [ "CONFIRMED", "SHIPPED", "DELIVERED" ] } // Only completed orders
        });

        // STEP 3: Initialize metrics calculation variables
        let sales = 0;          // Total number of items sold
        let revenue = 0;        // Total revenue generated
        const productSales = {}; // Object to track sales per product (productId: quantity)

        // STEP 4: Calculate metrics by iterating through all orders
        orders.forEach(order => {
            // Each order contains multiple items - iterate through each item
            order.items.forEach(item => {
                // Check if this item belongs to the current seller
                if (productIds.includes(item.product)) {
                    // Increment total sales count by item quantity
                    sales += item.quantity;
                    
                    // Calculate revenue: price Ã— quantity
                    revenue += item.price.amount * item.quantity;
                    
                    // Track sales per product for top products analysis
                    // productSales object key is productId, value is cumulative quantity
                    productSales[ item.product ] = (productSales[ item.product ] || 0) + item.quantity;
                }
            });
        });

        // STEP 5: Identify top 5 best-selling products
        // Convert productSales object to array, sort by quantity, take top 5
        const topProducts = Object.entries(productSales)
            .sort((a, b) => b[ 1 ] - a[ 1 ])  // Sort descending by quantity sold
            .slice(0, 5)  // Take only top 5 products
            .map(([ productId, qty ]) => {
                // Find product details for each top-selling product ID
                const prod = products.find(p => p._id.equals(productId));
                // Return enriched product data with sales quantity
                return prod ? { 
                    id: prod._id,      // Product ID
                    title: prod.title, // Product title/name
                    sold: qty          // Quantity sold
                } : null;
            })
            .filter(Boolean); // Remove any null entries (safety check)

        // STEP 6: Return calculated metrics as JSON response
        return res.json({
            sales,         // Total items sold
            revenue,       // Total revenue generated
            topProducts    // Array of top 5 products with sales data
        });
    } catch (error) {
        // Error handling for database or processing failures
        console.error("Error fetching metrics:", error)
        return res.status(500).json({
            message: "Internal Server Error"
        });
    }
}

// ==================== ORDERS CONTROLLER ====================
/**
 * GET /api/seller/dashboard/orders
 * Controller for fetching seller's order history
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @returns {Object} JSON response containing filtered order list
 */
async function getOrders(req, res) {
    try {
        // Extract authenticated seller from request
        const seller = req.user;

        // STEP 1: Get all products belonging to this seller
        const products = await productModel.find({ seller: seller._id });
        const productIds = products.map(p => p._id);

        // STEP 2: Find all orders containing seller's products
        // Includes all order statuses (not filtered like metrics)
        // .populate() joins user data (name, email) from user collection
        // .sort({ createdAt: -1 }) orders by most recent first
        const orders = await orderModel.find({
            'items.product': { $in: productIds }
        }).populate('user', 'name email')  // Get user's name and email
          .sort({ createdAt: -1 });        // Newest orders first

        // STEP 3: Filter order items to only include seller's products
        // Some orders may contain items from multiple sellers
        // This filters out items from other sellers
        const filteredOrders = orders.map(order => {
            // Filter items array to only include seller's products
            const filteredItems = order.items.filter(item => 
                productIds.includes(item.product)
            );
            
            // Return order with filtered items
            // .toObject() converts Mongoose document to plain JavaScript object
            return {
                ...order.toObject(),   // Spread all order properties
                items: filteredItems   // Replace items with filtered array
            };
        }).filter(order => order.items.length > 0); // Remove orders with no seller items

        // STEP 4: Return filtered orders
        return res.json(filteredOrders);
    } catch (error) {
        console.error("Error fetching orders:", error)
        return res.status(500).json({
            message: "Internal Server Error"
        });
    }
}

// ==================== PRODUCTS CONTROLLER ====================
/**
 * GET /api/seller/dashboard/products
 * Controller for fetching seller's product catalog
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @returns {Object} JSON response containing product list
 */
async function getProducts(req, res) {
    try {
        // Extract authenticated seller from request
        const seller = req.user;

        // Query productModel for all products belonging to this seller
        // .sort({ createdAt: -1 }) returns newest products first
        const products = await productModel.find({ 
            seller: seller._id 
        }).sort({ createdAt: -1 });

        // Return product array as JSON response
        return res.json(products);
    } catch (error) {
        console.error("Error fetching products:", error)
        return res.status(500).json({
            message: "Internal Server Error"
        });
    }
}

// ==================== MODULE EXPORTS ====================
// Export all controller functions for use in routes
module.exports = {
    getMetrics,   // Dashboard analytics endpoint
    getOrders,    // Order history endpoint
    getProducts   // Product catalog endpoint
}
```

## **File: `src/db/db.js`**
```javascript
// Import Mongoose ODM (Object Document Mapper) for MongoDB
// Mongoose provides schema-based solution to model application data
const mongoose = require('mongoose');

/**
 * Database Connection Function
 * Establishes connection to MongoDB database
 * Uses environment variable for connection string
 * @returns {Promise<void>} Resolves when connection is established
 */
async function connectDB() {
    try {
        // Establish connection to MongoDB using connection string from environment
        // process.env.MONGO_URI format: mongodb://username:password@host:port/database
        // mongoose.connect() returns a promise that resolves when connection is ready
        await mongoose.connect(process.env.MONGO_URI)
        
        // Log successful connection for monitoring
        console.log('Connected to MongoDB');
    } catch (error) {
        // Handle connection errors
        console.error('Error connecting to MongoDB:', error);
        
        // Exit application with failure code if database connection fails
        // Database is critical for this service, so exit if connection fails
        process.exit(1); // Exit code 1 indicates error/failure
    }
}

// Export the connection function for use in server.js
module.exports = connectDB;
```

## **File: `src/middlewares/auth.middleware.js`**
```javascript
// Import JSON Web Token library for token verification
// JWT is used for stateless authentication
const jwt = require('jsonwebtoken');

/**
 * Authentication Middleware Factory Function
 * Creates configured authentication middleware for route protection
 * @param {Array<string>} roles - Array of allowed roles (e.g., ["seller", "admin"])
 * @returns {Function} Express middleware function for authentication
 */
function createAuthMiddleware(roles = [ "user" ]) {
    
    // Return the actual middleware function that Express will execute
    return function authMiddleware(req, res, next) {
        // ==================== TOKEN EXTRACTION ====================
        // Attempt to extract JWT token from multiple sources
        // 1. From cookies: req.cookies?.token (optional chaining prevents errors)
        // 2. From Authorization header: Bearer <token> format
        // The || operator provides fallback if first source doesn't exist
        const token = req.cookies?.token || 
                      req.headers?.authorization?.split(' ')[1]; // Get token after "Bearer"

        // ==================== TOKEN VALIDATION ====================
        // Check if token exists
        if (!token) {
            // Return 401 Unauthorized if no token provided
            return res.status(401).json({
                message: 'Unauthorized: No token provided',
            });
        }

        try {
            // ==================== TOKEN VERIFICATION ====================
            // Verify JWT token using secret key from environment variables
            // jwt.verify() decodes and validates the token
            // Throws error if token is invalid, expired, or tampered with
            const decoded = jwt.verify(token, process.env.JWT_SECRET)

            // ==================== ROLE AUTHORIZATION ====================
            // Check if user's role is included in allowed roles array
            // This implements role-based access control (RBAC)
            if (!roles.includes(decoded.role)) {
                // Return 403 Forbidden if user lacks required role
                return res.status(403).json({
                    message: 'Forbidden: Insufficient permissions',
                });
            }

            // ==================== REQUEST ENRICHMENT ====================
            // Attach decoded user information to request object
            // Makes user data available to subsequent middleware and controllers
            req.user = decoded;
            
            // ==================== CONTINUE PROCESSING ====================
            // Call next() to pass control to the next middleware/controller
            // This is the successful path - authentication and authorization passed
            next();
        }
        catch (err) {
            // ==================== ERROR HANDLING ====================
            // Catch JWT verification errors (expired, invalid signature, etc.)
            return res.status(401).json({
                message: 'Unauthorized: Invalid token',
            });
        }
    }
}

// Export the middleware factory function
module.exports = createAuthMiddleware;
```

## **File: `src/models/order.model.js`**
```javascript
// Import Mongoose for schema definition and model creation
const mongoose = require('mongoose');

// ==================== ADDRESS SUB-SCHEMA ====================
/**
 * Address Schema Definition
 * Reusable schema for storing address information
 * Embedded document within order schema
 */
const addressSchema = new mongoose.Schema({
    street: String,   // Street address line
    city: String,     // City name
    state: String,    // State/Province
    zip: String,      // Postal/ZIP code
    country: String,  // Country name
});

// ==================== ORDER MAIN SCHEMA ====================
/**
 * Order Schema Definition
 * Defines structure of order documents in MongoDB
 * Each order represents a purchase transaction
 */
const orderSchema = new mongoose.Schema({
    // User Reference Field
    // Stores reference to user who placed the order
    user: {
        type: mongoose.Schema.Types.ObjectId, // MongoDB ObjectId type
        required: true,                       // Must have a user associated
        // No ref specified here - denormalized data from events
    },
    
    // Order Items Array
    // Contains products purchased in this order
    items: [
        {
            // Product Reference
            product: {
                type: mongoose.Schema.Types.ObjectId,
                required: true,
                // References product in seller-dashboard's local collection
            },
            
            // Quantity of this product in order
            quantity: {
                type: Number,
                default: 1,    // Default to 1 if not specified
                min: 1         // Must be at least 1
            },
            
            // Price information at time of purchase
            price: {
                // Monetary amount
                amount: {
                    type: Number,
                    required: true // Must have price amount
                },
                // Currency type with validation
                currency: {
                    type: String,
                    required: true,
                    enum: [ "USD", "INR" ] // Only allowed currency values
                }
            }
        }
    ],
    
    // Order Status Tracking
    status: {
        type: String,
        enum: [ 
            "PENDING",     // Order created, not confirmed
            "CONFIRMED",   // Order confirmed by seller/system
            "CANCELLED",   // Order cancelled
            "SHIPPED",     // Order shipped to customer
            "DELIVERED"    // Order delivered successfully
        ],
        // No default - populated from event data
    },
    
    // Total Order Price
    totalPrice: {
        amount: {
            type: Number,
            required: true // Sum of all item prices
        },
        currency: {
            type: String,
            required: true,
            enum: [ "USD", "INR" ] // Must match item currency
        }
    },
    
    // Shipping Address
    shippingAddress: {
        type: addressSchema, // Embedded address document
        required: true       // Must have shipping address
    },
    
}, { timestamps: true }); // Automatically adds createdAt and updatedAt fields

// ==================== MODEL CREATION ====================
/**
 * Create Mongoose Model from Schema
 * 'order' becomes collection name in MongoDB (pluralized to 'orders')
 */
const orderModel = mongoose.model("order", orderSchema);

// Export model for use in controllers and other modules
module.exports = orderModel;
```

## **File: `src/models/payment.model.js`**
```javascript
// Import Mongoose for schema definition
const mongoose = require('mongoose');

// ==================== PAYMENT SCHEMA DEFINITION ====================
/**
 * Payment Schema Definition
 * Tracks payment transactions for orders
 * Each payment document represents a financial transaction
 */
const paymentSchema = new mongoose.Schema({
    // Order Reference
    // Links payment to specific order
    order: { 
        type: mongoose.Schema.Types.ObjectId, 
        required: true // Every payment must be for an order
    },
    
    // Payment Gateway ID
    // External payment processor's transaction ID (if available)
    paymentId: { 
        type: String 
    },
    
    // Razorpay Order ID
    // Razorpay-specific order reference (required for Razorpay integration)
    razorpayOrderId: { 
        type: String, 
        required: true 
    },
    
    // Payment Signature
    // Cryptographic signature for webhook verification (security)
    signature: { 
        type: String 
    },
    
    // Payment Status
    // Tracks payment lifecycle
    status: { 
        type: String, 
        enum: [ 
            'PENDING',    // Payment initiated but not completed
            'COMPLETED',  // Payment successfully processed
            'FAILED'      // Payment failed/declined
        ], 
        default: 'PENDING' // Default status when payment created
    },
    
    // User Reference
    // User who made the payment
    user: { 
        type: mongoose.Schema.Types.ObjectId, 
        required: true 
    },
    
    // Payment Amount Details
    price: {
        // Transaction amount
        amount: { 
            type: Number, 
            required: true // Must have payment amount
        },
        // Currency with validation and defaults
        currency: { 
            type: String, 
            required: true, 
            default: 'INR', // Default to Indian Rupees
            enum: [ 'INR', "USD" ] // Supported currencies
        }
    }
    
}, { timestamps: true }); // Auto-add createdAt, updatedAt

// ==================== MODEL CREATION ====================
/**
 * Create Payment Model
 * 'payment' becomes collection name (pluralized to 'payments')
 */
const paymentModel = mongoose.model('payment', paymentSchema);

// Export model for database operations
module.exports = paymentModel;
```

## **File: `src/models/product.model.js`**
```javascript
// Import Mongoose for schema definition
const mongoose = require('mongoose');

// ==================== PRODUCT SCHEMA DEFINITION ====================
/**
 * Product Schema Definition
 * Defines structure for product documents in seller's catalog
 * Each product represents an item available for sale
 */
const productSchema = new mongoose.Schema({
    // Product Title/Name
    title: {
        type: String,
        required: true // Must have a product name
    },
    
    // Product Description
    description: {
        type: String, // Detailed product information
        // Not required - some products might not have descriptions
    },
    
    // Pricing Information
    price: {
        // Product price amount
        amount: {
            type: Number,
            required: true // Must have price
        },
        // Currency with validation
        currency: {
            type: String,
            enum: [ 'USD', 'INR' ], // Supported currencies
            default: 'INR'          // Default to Indian Rupees
        }
    },
    
    // Seller Reference
    // Which seller owns/created this product
    seller: {
        type: mongoose.Schema.Types.ObjectId,
        required: true, // Every product must have a seller
        // References user in seller-dashboard's local collection
    },
    
    // Product Images Array
    // Stores multiple images for product gallery
    images: [
        {
            url: String,        // Full-size image URL
            thumbnail: String,  // Thumbnail image URL (for faster loading)
            id: String          // Image identifier (could be cloud storage ID)
        }
    ],
    
    // Inventory Stock Level
    stock: {
        type: Number,
        default: 0 // Default to 0 (out of stock) if not specified
    }
})

// ==================== TEXT SEARCH INDEX ====================
/**
 * Create text index for search functionality
 * Enables full-text search on title and description fields
 * MongoDB will create a searchable index for these fields
 */
productSchema.index({ title: 'text', description: 'text' });

// ==================== MODEL CREATION ====================
/**
 * Create and export Product Model
 * 'product' becomes collection name (pluralized to 'products')
 */
module.exports = mongoose.model('product', productSchema);
```

## **File: `src/models/user.model.js`**
```javascript
// Import Mongoose for schema definition
const mongoose = require('mongoose');

// ==================== ADDRESS SUB-SCHEMA ====================
/**
 * Address Schema Definition
 * Reusable schema for storing user addresses
 * Embedded within user document
 */
const addressSchema = new mongoose.Schema({
    street: String,           // Street address
    city: String,             // City
    state: String,            // State/Province
    zip: String,              // Postal code
    country: String,          // Country
    isDefault: { 
        type: Boolean, 
        default: false  // Mark if this is user's primary address
    }
});

// ==================== USER MAIN SCHEMA ====================
/**
 * User Schema Definition
 * Defines structure for user/seller documents
 * This is a denormalized copy from auth service events
 */
const userSchema = new mongoose.Schema({
    // Username Field
    username: {
        type: String,
        required: true,   // Must have username
        unique: true      // Usernames must be unique across all users
    },
    
    // Email Field
    email: {
        type: String,
        required: true,   // Must have email
        unique: true      // Emails must be unique
    },
    
    // Password Field (for reference, not used in dashboard)
    password: {
        type: String,
        select: false,    // Security: Never include in queries by default
        // This is a copy from auth service, not used here
    },
    
    // Full Name Structure
    fullName: {
        firstName: { 
            type: String, 
            required: true  // Must have first name
        },
        lastName: { 
            type: String, 
            required: true  // Must have last name
        }
    },
    
    // User Role
    role: {
        type: String,
        enum: [ 'user', 'seller' ], // Allowed roles
        default: 'user'              // Default to regular user
    },
    
    // User Addresses Array
    addresses: [
        addressSchema  // Embed address documents
    ]
})

// ==================== MODEL CREATION ====================
/**
 * Create User Model
 * 'user' becomes collection name (pluralized to 'users')
 */
const userModel = mongoose.model('user', userSchema);

// Export model for database operations
module.exports = userModel;
```

## **File: `src/routes/seller.routes.js`**
```javascript
// Import Express Router for creating modular route handlers
const express = require('express');

// Import authentication middleware factory function
// This creates role-specific authentication middleware
const createAuthMiddleware = require('../middlewares/auth.middleware');

// Import seller controller functions
// Contains business logic for each route endpoint
const controller = require("../controllers/seller.controller")

// Create Express Router instance
// Router allows grouping related routes with common middleware
const router = express.Router();

// ==================== ROUTE DEFINITIONS ====================
// All routes are under /api/seller/dashboard (defined in app.js)

/**
 * GET /api/seller/dashboard/metrics
 * Retrieves seller performance metrics and analytics
 * 
 * Route Flow:
 * 1. createAuthMiddleware(["seller"]) - Only sellers can access
 * 2. controller.getMetrics - Business logic for metrics calculation
 */
router.get(
    "/metrics",                          // Route path
    createAuthMiddleware([ "seller" ]),  // Auth: Only seller role allowed
    controller.getMetrics                // Controller: Metrics calculation logic
)

/**
 * GET /api/seller/dashboard/orders
 * Retrieves seller's order history
 * 
 * Route Flow:
 * 1. Authentication check for seller role
 * 2. Order data retrieval and filtering
 */
router.get(
    "/orders",                           // Route path
    createAuthMiddleware([ "seller" ]),  // Auth: Seller role required
    controller.getOrders                 // Controller: Order retrieval logic
)

/**
 * GET /api/seller/dashboard/products
 * Retrieves seller's product catalog
 * 
 * Route Flow:
 * 1. Seller authentication
 * 2. Product listing from seller's catalog
 */
router.get(
    "/products",                         // Route path  
    createAuthMiddleware([ "seller" ]),  // Auth: Seller role required
    controller.getProducts               // Controller: Product retrieval logic
)

// ==================== MODULE EXPORT ====================
// Export the configured router for use in app.js
module.exports = router;
```