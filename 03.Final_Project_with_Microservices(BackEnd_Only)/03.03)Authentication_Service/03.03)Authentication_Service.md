# ğŸ“ `src/app.js`

## APPLICATION BOOTSTRAP ALGORITHM

### Purpose

Initialize Express app, attach global middlewares, and register routes.

### Algorithm

1. Create an Express application instance.
2. Attach JSON body parser middleware:
   â†’ Automatically parse incoming JSON request bodies into `req.body`.
3. Attach cookie parser middleware:
   â†’ Parse cookies from incoming requests and attach them to `req.cookies`.
4. Define a health-check route (`GET /`):
   â†’ When accessed, respond with HTTP 200 and a JSON message confirming service is alive.
5. Import authentication routes from `routes/auth.routes`.
6. Mount authentication routes under `/api/auth`:
   â†’ All auth-related endpoints are namespaced.
7. Export the Express app instance:
   â†’ Used by server entry point or tests.

---

# ğŸ“ `src/broker/borker.js` (RabbitMQ)

## GLOBAL STATE INITIALIZATION

### Purpose

Maintain a single RabbitMQ connection and channel across the app lifecycle.

---

## `connect()` â€” Establish RabbitMQ connection

### Algorithm

1. Check if a RabbitMQ connection already exists:
   â†’ If yes, return immediately (singleton behavior).
2. Attempt to connect to RabbitMQ using `RABBIT_URL`.
3. On successful connection:
   â†’ Store connection in module-level variable.
   â†’ Create a channel and store it.
4. Log successful connection.
5. On failure:
   â†’ Log error details (no crash).
6. Leave retry/recovery responsibility to caller or infrastructure.

---

## `publishToQueue(queueName, data)`

### Purpose

Send a durable message to a RabbitMQ queue.

### Algorithm

1. Check whether connection/channel exists:
   â†’ If not, call `connect()`.
2. Assert the queue exists:
   â†’ Ensure durability (`durable: true`) so messages survive broker restarts.
3. Serialize data to JSON.
4. Convert serialized data into a binary buffer.
5. Publish message to the queue.
6. Log queue name and message payload.

---

## `subscribeToQueue(queueName, callback)`

### Purpose

Consume messages from a queue and process them asynchronously.

### Algorithm

1. Ensure RabbitMQ connection/channel exists.
2. Assert the queue with durability enabled.
3. Start consuming messages from the queue.
4. On message arrival:
   â†’ Parse message content from buffer to JSON.
   â†’ Pass parsed data to provided callback.
   â†’ Await callback execution.
5. After successful processing:
   â†’ Acknowledge message (ACK) to RabbitMQ.
6. Prevent message re-delivery after ACK.

---

# ğŸ“ `src/controllers/auth.controller.js`

---

## `registerUser(req, res)` â€” **EXTREMELY DETAILED**

### Purpose

Register a new user, publish events, and issue authentication token.

### Algorithm

1. Extract from request body:
   â†’ `username`
   â†’ `email`
   â†’ `password`
   â†’ `fullName.firstName`
   â†’ `fullName.lastName`
   â†’ `role` (optional)
2. Query database:
   â†’ Find user where username OR email already exists.
3. If user exists:
   â†’ Respond with `409 Conflict`.
   â†’ Stop execution.
4. Hash password using bcrypt:
   â†’ Use salt rounds = 10.
   â†’ Never store raw password.
5. Create new user record with:
   â†’ username
   â†’ email
   â†’ hashed password
   â†’ fullName object
   â†’ role (default = `user`)
6. Publish events in parallel:
   â†’ Notification service receives minimal user data.
   â†’ Seller dashboard receives full user object.
7. Generate JWT token:
   â†’ Payload: `{ id, username, email, role }`
   â†’ Secret: `JWT_SECRET`
   â†’ Expiry: 1 day
8. Store JWT in HTTP-only secure cookie.
9. Respond with:
   â†’ HTTP 201
   â†’ User metadata (excluding password).

---

## `loginUser(req, res)`

### Purpose

Authenticate existing user and issue JWT.

### Algorithm

1. Extract `email`, `username`, and `password` from request.
2. Query database:
   â†’ Match user by email OR username.
   â†’ Explicitly include password field.
3. If user not found:
   â†’ Respond `401 Unauthorized`.
4. Compare provided password with stored hash.
5. If mismatch:
   â†’ Respond `401 Unauthorized`.
6. Generate JWT token (same format as registration).
7. Set token in HTTP-only secure cookie.
8. Respond `200 OK` with user data.

---

## `getCurrentUser(req, res)`

### Purpose

Return authenticated user's identity.

### Algorithm

1. Assume authentication middleware already validated token.
2. Read user data from `req.user`.
3. Respond `200 OK` with user payload.

---

## `logoutUser(req, res)`

### Purpose

Invalidate JWT and log user out.

### Algorithm

1. Extract token from cookies.
2. If token exists:
   â†’ Store `blacklist:{token}` = true in Redis.
   â†’ Set expiration = token lifetime (1 day).
3. Clear authentication cookie.
4. Respond `200 OK`.

---

## `getUserAddresses(req, res)`

### Purpose

Fetch user's saved addresses.

### Algorithm

1. Extract user ID from `req.user`.
2. Query DB for user and select only addresses.
3. If user not found:
   â†’ Respond `404 Not Found`.
4. Respond `200 OK` with address list.

---

## `addUserAddress(req, res)`

### Purpose

Add a new address to user profile.

### Algorithm

1. Extract user ID from auth context.
2. Extract address fields from request body.
3. Update user:
   â†’ Push new address into `addresses` array.
4. If user not found:
   â†’ Respond `404`.
5. Return newly added address.
6. Respond `201 Created`.

---

## `deleteUserAddress(req, res)`

### Purpose

Remove a specific address.

### Algorithm

1. Extract user ID and address ID.
2. Verify address exists for user.
3. If address not found:
   â†’ Respond `404`.
4. Remove address using `$pull`.
5. Verify deletion succeeded.
6. Respond `200 OK` with updated addresses.

---

# ğŸ“ `src/db/db.js`

## `connectDB()`

### Purpose

Initialize MongoDB connection.

### Algorithm

1. Attempt connection using `MONGO_URI`.
2. On success:
   â†’ Log confirmation.
3. On failure:
   â†’ Log error details.

---

# ğŸ“ `src/db/redis.js`

## Redis Selection Logic

### Purpose

Provide Redis abstraction with test safety.

### Algorithm

1. Check environment:
   â†’ If `NODE_ENV === test`:

   * Use in-memory FakeRedis.
2. FakeRedis behavior:
   â†’ Store key-value pairs in Map.
   â†’ Track expirations manually.
   â†’ Simulate `set`, `get`, `del`.
3. Production Redis:
   â†’ Connect using host, port, password.
   â†’ Listen for connection events.
4. Export Redis instance.

---

# ğŸ“ `src/middlewares/auth.middleware.js`

## `authMiddleware(req, res, next)`

### Purpose

Protect routes using JWT authentication.

### Algorithm

1. Read token from cookies.
2. If token missing:
   â†’ Respond `401 Unauthorized`.
3. Verify JWT using secret.
4. If verification fails:
   â†’ Respond `401 Unauthorized`.
5. Attach decoded payload to `req.user`.
6. Call `next()`.

---

# ğŸ“ `src/middlewares/validator.middleware.js`

## Validation Pipeline Algorithm

### Purpose

Ensure request data integrity before controllers run.

---

### `respondWithValidationErrors`

1. Collect validation errors.
2. If errors exist:
   â†’ Respond `400 Bad Request`.
3. Otherwise:
   â†’ Call `next()`.

---

### `registerUserValidations`

1. Validate username (string, length â‰¥ 3).
2. Validate email format.
3. Validate password length.
4. Validate first & last name presence.
5. Validate role if present.
6. Return validation errors if any.

---

### `loginUserValidations`

1. Ensure either email or username exists.
2. Validate password length.
3. Reject invalid combinations.

---

### `addUserAddressValidations`

1. Validate street, city, state.
2. Validate pincode numeric format.
3. Validate country.
4. Validate optional phone & isDefault.
5. Reject invalid payloads.

---

# ğŸ“ `src/models/user.model.js`

## Schema Design Algorithm

### Purpose

Define persistent user data model.

### Algorithm

1. Define address sub-schema.
2. Define user schema with:
   â†’ Unique username
   â†’ Unique email
   â†’ Password excluded by default
   â†’ Embedded fullName object
   â†’ Role enum
   â†’ Addresses array
3. Compile and export model.

---

# ğŸ“ `src/routes/auth.routes.js`

## Routing Flow Algorithm

### Purpose

Map HTTP endpoints to middleware and controllers.

### Algorithm

1. Initialize router.
2. Register routes in order:
   â†’ Apply validation middleware.
   â†’ Apply auth middleware when needed.
   â†’ Call controller.
3. Export router.

---


# ğŸ“ `test/setup.js`

## PURPOSE

Global Jest lifecycle configuration for **isolated, repeatable integration tests** using an **in-memory MongoDB**.

---

## GLOBAL TEST ENVIRONMENT SETUP ALGORITHM

### `beforeAll` (runs once before all tests)

1. Start an in-memory MongoDB instance.
2. Retrieve the generated MongoDB connection URI.
3. Inject the URI into `process.env.MONGO_URI`:
   â†’ Ensures application DB connector uses test DB.
4. Inject a test-only JWT secret into environment.
5. Establish a Mongoose connection to the in-memory database.
6. Ensure DB is ready before any test executes.

---

### `afterEach` (runs after every test case)

1. Fetch all collections from the active database.
2. Iterate through each collection.
3. Remove **all documents** from each collection.
4. Guarantee **test isolation**:
   â†’ No data leakage between test cases.

---

### `afterAll` (runs once after all tests)

1. Close active Mongoose connection.
2. Stop in-memory MongoDB instance.
3. Release all DB resources cleanly.

---

## WHY THIS FILE IS CRITICAL

* Guarantees **deterministic tests**
* Prevents dependency on local/remote MongoDB
* Eliminates flaky test behavior
* Ensures clean teardown

---

# ğŸ“ `__tests__/auth.register.test.js`

## PURPOSE

Validate **user registration flow**, validation rules, and duplicate handling.

---

## TEST SUITE: `POST /api/auth/register`

### Global Setup

1. Connect application to in-memory MongoDB.
2. Ensure test DB is used via `setup.js`.

---

### TEST CASE 1 â€” Successful registration

**Scenario**

* Valid payload provided.

**Algorithm**

1. Send POST request with valid user data.
2. Expect HTTP `201 Created`.
3. Verify response contains `user`.
4. Assert:
   â†’ username matches
   â†’ email matches
   â†’ password is NOT returned.
5. Confirms:
   â†’ hashing works
   â†’ schema `select:false` works
   â†’ happy path works.

---

### TEST CASE 2 â€” Duplicate username/email

**Scenario**

* Same payload sent twice.

**Algorithm**

1. Send first registration request â†’ expect success.
2. Send second request with same data.
3. Expect HTTP `409 Conflict`.
4. Confirms:
   â†’ uniqueness checks are enforced.

---

### TEST CASE 3 â€” Validation failure

**Scenario**

* Empty payload.

**Algorithm**

1. Send POST request with empty body.
2. Expect HTTP `400 Bad Request`.
3. Confirms:
   â†’ validation middleware is active
   â†’ controller not executed on invalid input.

---

# ğŸ“ `__tests__/auth.login.test.js`

## PURPOSE

Verify authentication logic, password validation, and cookie issuance.

---

## TEST SUITE: `POST /api/auth/login`

### Global Setup

1. Connect to in-memory MongoDB.

---

### TEST CASE 1 â€” Correct credentials

**Algorithm**

1. Seed user with hashed password.
2. Send login request with correct credentials.
3. Expect HTTP `200 OK`.
4. Verify:
   â†’ response contains user object
   â†’ auth cookie (`token`) is set.
5. Confirms:
   â†’ bcrypt comparison works
   â†’ JWT is generated
   â†’ cookie logic works.

---

### TEST CASE 2 â€” Wrong password

**Algorithm**

1. Seed user.
2. Send login request with wrong password.
3. Expect HTTP `401 Unauthorized`.
4. Expect message "Invalid credentials".
5. Confirms:
   â†’ incorrect credentials are rejected.

---

### TEST CASE 3 â€” Missing fields

**Algorithm**

1. Send login request with empty body.
2. Expect HTTP `400 Bad Request`.
3. Expect validation errors.
4. Confirms:
   â†’ validator middleware is enforced.

---

# ğŸ“ `__tests__/auth.me.test.js`

## PURPOSE

Validate authentication middleware and current-user retrieval.

---

## TEST SUITE: `GET /api/auth/me`

---

### TEST CASE 1 â€” No cookie

**Algorithm**

1. Call endpoint without cookies.
2. Expect HTTP `401 Unauthorized`.
3. Confirms:
   â†’ auth middleware blocks unauthenticated access.

---

### TEST CASE 2 â€” Invalid token

**Algorithm**

1. Generate JWT with wrong secret.
2. Send request with fake token cookie.
3. Expect HTTP `401 Unauthorized`.
4. Confirms:
   â†’ JWT verification works
   â†’ invalid tokens rejected.

---

### TEST CASE 3 â€” Valid token

**Algorithm**

1. Seed user.
2. Log in to obtain valid cookie.
3. Call `/me` with cookie.
4. Expect HTTP `200 OK`.
5. Verify:
   â†’ returned user ID matches DB user
   â†’ email and username match.
6. Confirms:
   â†’ auth middleware attaches decoded payload correctly.

---

# ğŸ“ `__tests__/auth.logout.test.js`

## PURPOSE

Ensure logout behavior is safe, idempotent, and cookie-clearing works.

---

## TEST SUITE: `GET /api/auth/logout`

---

### TEST CASE 1 â€” Logged-in user

**Algorithm**

1. Seed user.
2. Login to obtain cookie.
3. Call logout endpoint with cookie.
4. Expect HTTP `200 OK`.
5. Verify response headers:
   â†’ `token` cookie cleared
   â†’ expiration set.
6. Confirms:
   â†’ cookie invalidation works.

---

### TEST CASE 2 â€” No cookie

**Algorithm**

1. Call logout endpoint without cookies.
2. Expect HTTP `200 OK`.
3. Confirms:
   â†’ logout is idempotent
   â†’ safe for repeated calls.

---

# ğŸ“ `__tests__/auth.addresses.test.js`

## PURPOSE

Validate **address CRUD operations**, validation, and authentication enforcement.

---

## SHARED HELPER â€” `seedUserAndLogin`

### Algorithm

1. Hash password.
2. Create user in DB.
3. Log in user via API.
4. Extract auth cookies.
5. Return `{ user, cookies }`.

---

## TEST SUITE: `GET /users/me/addresses`

### TEST CASE â€” Auth required

1. Call endpoint without cookie.
2. Expect HTTP `401 Unauthorized`.

---

### TEST CASE â€” List addresses

1. Seed user and login.
2. Manually insert addresses into DB.
3. Call endpoint with auth cookie.
4. Expect:
   â†’ HTTP `200`
   â†’ array of addresses
   â†’ default address identified.
5. Confirms:
   â†’ address retrieval works
   â†’ default logic respected.

---

## TEST SUITE: `POST /users/me/addresses`

### TEST CASE â€” Invalid input

1. Send request with invalid pincode.
2. Expect HTTP `400 Bad Request`.
3. Confirms:
   â†’ validation middleware enforces rules.

---

### TEST CASE â€” Add address

1. Send valid address payload.
2. Expect HTTP `200/201`.
3. Verify:
   â†’ address returned
   â†’ default flag respected.
4. Confirms:
   â†’ address creation works.

---

## TEST SUITE: `DELETE /users/me/addresses/:id`

### TEST CASE â€” Successful delete

1. Seed user with multiple addresses.
2. Delete one address by ID.
3. Expect HTTP `200 OK`.
4. Verify address list updated.
5. Confirms:
   â†’ deletion logic works.

---

### TEST CASE â€” Address not found

1. Generate fake ObjectId.
2. Attempt deletion.
3. Expect HTTP `404 Not Found`.
4. Confirms:
   â†’ safety check before deletion.

---
