## src/app.js

```text
APP PURPOSE:
â†’ configure Express, parse JSON & cookies, expose health route, mount payment routes.

APP ALGORITHM:
â†’ create Express app
â†’ enable express.json() middleware
â†’ enable cookieParser() middleware
â†’ register GET / route returning service health message
â†’ mount payment routes at /api/payments
â†’ export app instance
```

---

## src/broker/borker.js â€” connect

```text
CONNECT TO RABBITMQ ALGORITHM:
â†’ if connection already exists:
    â†’ return existing connection
â†’ try:
    â†’ connect to RabbitMQ using RABBIT_URL
    â†’ create channel from connection
    â†’ log successful connection
â†’ catch error:
    â†’ log connection failure
```

---

## src/broker/borker.js â€” publishToQueue

```text
PUBLISH TO QUEUE ALGORITHM:
â†’ if channel or connection not initialized:
    â†’ call connect()
â†’ assert queue with durable = true
â†’ serialize data to JSON buffer
â†’ send message to queue
â†’ log queue name and payload
```

---

## src/broker/borker.js â€” subscribeToQueue

```text
SUBSCRIBE TO QUEUE ALGORITHM:
â†’ if channel or connection not initialized:
    â†’ call connect()
â†’ assert queue with durable = true
â†’ consume messages from queue:
    â†’ if message exists:
        â†’ parse JSON payload
        â†’ execute callback(payload)
        â†’ acknowledge message
```

---

## src/db/db.js

```text
DATABASE CONNECTION ALGORITHM:
â†’ try:
    â†’ connect mongoose using MONGO_URI
    â†’ log successful connection
â†’ catch error:
    â†’ log connection error
```

---

## src/middlewares/auth.middleware.js

```text
AUTH MIDDLEWARE FACTORY ALGORITHM:
â†’ accept allowed roles (default: ["user"])
â†’ return middleware function:
    â†’ extract token from cookies or Authorization header
    â†’ if token missing:
        â†’ return 401 Unauthorized
    â†’ try:
        â†’ verify token using JWT_SECRET
        â†’ if decoded role not in allowed roles:
            â†’ return 403 Forbidden
        â†’ attach decoded payload to req.user
        â†’ call next()
    â†’ catch verification error:
        â†’ return 401 Unauthorized
```

---

## src/models/payment.model.js

```text
PAYMENT MODEL SCHEMA LOGIC:
â†’ required fields:
    â†’ order (ObjectId)
    â†’ razorpayOrderId (String)
    â†’ user (ObjectId)
    â†’ price.amount (Number)
    â†’ price.currency (INR | USD)
â†’ optional fields:
    â†’ paymentId
    â†’ signature
â†’ status enum:
    â†’ PENDING (default)
    â†’ COMPLETED
    â†’ FAILED
â†’ automatically store createdAt and updatedAt timestamps
```

---

## src/routes/payment.routes.js

```text
PAYMENT ROUTES ALGORITHM:
â†’ POST /create/:orderId
    â†’ apply auth middleware with role "user"
    â†’ invoke createPayment controller
â†’ POST /verify
    â†’ apply auth middleware with role "user"
    â†’ invoke verifyPayment controller
```

---

## src/controllers/payment.controller.js â€” createPayment

```text
CREATE PAYMENT ALGORITHM:
â†’ extract auth token from cookies or Authorization header
â†’ extract orderId from route params
â†’ request order details from Orders service using bearer token
â†’ extract totalPrice from order response
â†’ create Razorpay order using totalPrice
â†’ create local payment record with:
    â†’ orderId
    â†’ razorpayOrderId
    â†’ userId
    â†’ price (amount, currency)
â†’ persist payment in database
â†’ publish PAYMENT_CREATED event to seller dashboard queue
â†’ publish PAYMENT_INITIATED notification event
â†’ return 201 Created with payment data
â†’ on any error:
    â†’ log error
    â†’ return 500 Internal Server Error
```

---

## src/controllers/payment.controller.js â€” verifyPayment

```text
VERIFY PAYMENT ALGORITHM:
â†’ extract razorpayOrderId, paymentId, signature from request body
â†’ validate signature using Razorpay utility and secret key
â†’ if signature invalid:
    â†’ return 400 Invalid signature
â†’ find payment with matching razorpayOrderId and status = PENDING
â†’ if payment not found:
    â†’ return 404 Payment not found
â†’ update payment:
    â†’ set paymentId
    â†’ set signature
    â†’ set status = COMPLETED
â†’ save payment
â†’ publish PAYMENT_COMPLETED notification event
â†’ publish PAYMENT_UPDATED event to seller dashboard queue
â†’ return 200 OK with updated payment
â†’ on any error:
    â†’ log error
    â†’ publish PAYMENT_FAILED notification event
    â†’ return 500 Internal Server Error
```

---

## ðŸ“„ `payment.controller.js` â€” fully commented (line by line)

```js
const paymentModel = require('../models/payment.model');

// Axios is used to make HTTP calls to other microservices (Orders service)
const axios = require('axios');

// Import RabbitMQ publisher to emit events to other services
const { publishToQueue } = require("../broker/borker")

// Load environment variables from .env file
require('dotenv').config();

// Import Razorpay SDK
const Razorpay = require('razorpay');

// Create a Razorpay client instance using secret keys
// This object is used to create and verify payments with Razorpay
const razorpay = new Razorpay({
    key_id: process.env.RAZORPAY_KEY_ID,        // public key
    key_secret: process.env.RAZORPAY_KEY_SECRET // private key
});


// ======================= CREATE PAYMENT =======================
// Purpose:
// 1. Fetch order details from Orders service
// 2. Create a Razorpay order
// 3. Store a local payment record
// 4. Publish payment initiation events
async function createPayment(req, res) {

    // Extract JWT token either from cookies or Authorization header
    // Supports both browser-based and API-based authentication
    const token = req.cookies?.token || req.headers?.authorization?.split(' ')[1];

    try {
        // Extract orderId from URL parameter
        const orderId = req.params.orderId;

        // Call Orders microservice to fetch order details
        // The same JWT token is forwarded to maintain user identity
        const orderResponse = await axios.get(
            "http://nova-alb-551701734.ap-northeast-3.elb.amazonaws.com/api/orders/" + orderId,
            {
                headers: {
                    Authorization: `Bearer ${token}`
                }
            }
        );

        // Extract total price from the order response
        // Expected shape: { amount, currency }
        const price = orderResponse.data.order.totalPrice;

        // Create a Razorpay order
        // Razorpay expects amount in smallest unit (paise/cents)
        const order = await razorpay.orders.create(price);

        // Create a local payment record in MongoDB
        const payment = await paymentModel.create({
            order: orderId,                 // reference to order
            razorpayOrderId: order.id,      // Razorpay order identifier
            user: req.user.id,              // authenticated user ID
            price: {
                amount: order.amount,       // amount from Razorpay
                currency: order.currency    // INR / USD
            }
        });

        // Publish event for seller dashboard service
        // This allows seller systems to show "payment initiated"
        await publishToQueue(
            "PAYMENT_SELLER_DASHBOARD.PAYMENT_CREATED",
            payment
        );

        // Publish event for notification service (email / SMS)
        await publishToQueue(
            "PAYMENT_NOTIFICATION.PAYMENT_INITIATED",
            {
                email: req.user.email,
                orderId: orderId,
                amount: price.amount / 100, // convert paise â†’ rupees
                currency: price.currency,
                username: req.user.username,
            }
        );

        // Respond to client with success and payment details
        return res.status(201).json({
            message: 'Payment initiated',
            payment
        });

    } catch (err) {
        // Log error for debugging
        console.log(err);

        // Return generic error to client
        return res.status(500).json({
            message: 'Internal Server Error'
        });
    }
}


// ======================= VERIFY PAYMENT =======================
// Purpose:
// 1. Validate Razorpay signature
// 2. Mark payment as COMPLETED
// 3. Publish success or failure events
async function verifyPayment(req, res) {

    // Extract Razorpay verification fields from request body
    const { razorpayOrderId, paymentId, signature } = req.body;

    // Razorpay secret used to verify signature
    const secret = process.env.RAZORPAY_KEY_SECRET;

    try {
        // Import Razorpay utility for signature verification
        // (Direct import from SDK internals)
        const { validatePaymentVerification } =
            require('../../node_modules/razorpay/dist/utils/razorpay-utils.js');

        // Validate payment signature
        const isValid = validatePaymentVerification(
            {
                order_id: razorpayOrderId,
                payment_id: paymentId
            },
            signature,
            secret
        );

        // If signature does not match, reject request
        if (!isValid) {
            return res.status(400).json({
                message: 'Invalid signature'
            });
        }

        // Find pending payment matching Razorpay order ID
        const payment = await paymentModel.findOne({
            razorpayOrderId,
            status: 'PENDING'
        });

        // If payment does not exist or already processed
        if (!payment) {
            return res.status(404).json({
                message: 'Payment not found'
            });
        }

        // Update payment fields
        payment.paymentId = paymentId;
        payment.signature = signature;
        payment.status = 'COMPLETED';

        // Persist updated payment to database
        await payment.save();

        // Notify user about successful payment
        await publishToQueue(
            "PAYMENT_NOTIFICATION.PAYMENT_COMPLETED",
            {
                email: req.user.email,
                orderId: payment.order,
                paymentId: payment.paymentId,
                amount: payment.price.amount / 100,
                currency: payment.price.currency,
                fullName: req.user.fullName
            }
        );

        // Notify seller dashboard about payment update
        await publishToQueue(
            "PAYMENT_SELLER_DASHBOARD.PAYMENT_UPDATED",
            payment
        );

        // Respond to client with success
        res.status(200).json({
            message: 'Payment verified successfully',
            payment
        });

    } catch (err) {
        // Log error
        console.log(err);

        // Publish failure notification
        await publishToQueue(
            "PAYMENT_NOTIFICATION.PAYMENT_FAILED",
            {
                email: req.user.email,
                paymentId: paymentId,
                orderId: razorpayOrderId,
                fullName: req.user.fullName
            }
        );

        // Respond with server error
        return res.status(500).json({
            message: 'Internal Server Error'
        });
    }
}


// Export controller functions
module.exports = {
    createPayment,
    verifyPayment
};
```

---

## ðŸ“„ `payment.routes.js` â€” fully commented (line by line)

```js
// Import Express framework
const express = require('express');

// Import authentication middleware factory
// Used to protect routes and enforce role-based access
const createAuthMiddleware = require("../middlewares/auth.middleware");

// Import payment controller containing business logic
const paymentController = require("../controllers/payment.controller");

// Create a new Express router instance
// This router groups all payment-related routes
const router = express.Router();


// ======================= CREATE PAYMENT ROUTE =======================
// HTTP Method: POST
// URL: /api/payments/create/:orderId
// Access: authenticated users only
router.post(
    "/create/:orderId",

    // Authentication middleware:
    // - validates JWT
    // - ensures role is "user"
    createAuthMiddleware([ "user" ]),

    // Controller function that handles payment creation
    paymentController.createPayment
);


// ======================= VERIFY PAYMENT ROUTE =======================
// HTTP Method: POST
// URL: /api/payments/verify
// Access: authenticated users only
router.post(
    "/verify",

    // Authentication middleware:
    // - validates JWT
    // - ensures role is "user"
    createAuthMiddleware([ "user" ]),

    // Controller function that verifies payment
    paymentController.verifyPayment
);


// Export router to be mounted in app.js
module.exports = router;
```

---