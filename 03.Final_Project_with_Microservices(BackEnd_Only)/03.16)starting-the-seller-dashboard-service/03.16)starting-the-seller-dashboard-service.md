# ğŸ¯ API Endpoints in Question

```
GET /seller/dashboard/matrics
GET /seller/dashboard/orders
GET /seller/dashboard/products
```

These are **seller dashboard read APIs**.

---

# ğŸ§  BIG PICTURE (one sentence)

> A request enters `server.js` â†’ reaches `app.js` â†’ routed via `seller.routes.js` â†’ authenticated by `auth.middleware.js` â†’ handled by `seller.controller.js` â†’ fetches data from `models` â†’ response returned.

Now letâ€™s break it **layer by layer**, **file by file**, **line of execution**.

---

# 1ï¸âƒ£ Application Boot Sequence (ONLY ONCE)

This happens **when you run**:

```bash
node server.js
```

---

## ğŸ“„ `server.js` â€” *Entry Point*

### Purpose

* Start DB
* Start message listeners
* Start HTTP server

### What runs immediately (top-level)

```
connectDB()
listener()
app.listen(...)
```

### Why this order matters

1. **connectDB()**

   * Ensures MongoDB is connected **before** requests arrive
   * Prevents runtime DB crashes

2. **listener()**

   * Imports `broker/listener.js`
   * Subscribes to RabbitMQ queues
   * Runs independently of HTTP

3. **app.listen()**

   * Starts Express server
   * Now APIs are accessible

âš ï¸ This file **never handles business logic** â€” it only wires things together.

---

# 2ï¸âƒ£ Express App Setup

## ğŸ“„ `src/app.js`

### Purpose

* Create Express instance
* Register global middlewares
* Attach routes

### What it exports

```
module.exports = app
```

### What it does conceptually

```
app = express()
app.use(json, cookieParser, etc)
app.use("/seller", sellerRoutes)
```

This file **does NOT know**:

* What `/seller/dashboard/products` does
* How authentication works
* How data is fetched

It only **delegates responsibility**.

---

# 3ï¸âƒ£ Routing Layer (URL â†’ Function mapping)

## ğŸ“„ `src/routes/seller.routes.js`

### Purpose

* Define seller-specific endpoints
* Attach middleware + controllers

### Example conceptual mapping

```
GET /seller/dashboard/matrics   â†’ getMetrics
GET /seller/dashboard/orders   â†’ getOrders
GET /seller/dashboard/products â†’ getProducts
```

### Why routes are separate

* Keeps URL logic isolated
* Easy to add versioning later (`/v2/seller`)
* Controllers stay clean

Routes **never talk to DB**.

---

# 4ï¸âƒ£ Authentication Layer

## ğŸ“„ `src/middlewares/auth.middleware.js`

### Purpose

* Verify seller identity
* Protect routes

### How it works conceptually

1. Extract token (cookie/header)
2. Verify JWT
3. Attach user to `req.user`
4. Call `next()`

### Why `next()` matters

* `next()` hands control to the **controller**
* Without `next()`, request **stops here**

### Execution timing

This middleware runs **on every request**, not at startup.

---

# 5ï¸âƒ£ Controller Layer (Business Logic)

## ğŸ“„ `src/controllers/seller.controller.js`

This is the **heart of your APIs**.

---

## ğŸ§© `getMetrics()`

### Endpoint

```
GET /seller/dashboard/matrics
```

### Purpose

* Show seller performance summary

### Typical responsibilities

* Count orders
* Sum revenue
* Maybe compute growth

### What it uses

* `order.model.js`
* `payment.model.js`

### What it does NOT do

* No authentication
* No routing
* No schema definition

---

## ğŸ§© `getOrders()`

### Endpoint

```
GET /seller/dashboard/orders
```

### Purpose

* List seller orders

### Responsibilities

* Filter orders by seller ID
* Pagination / sorting
* Status filtering

### Typical DB usage

```
Order.find({ seller: req.user.id })
```

---

## ğŸ§© `getProducts()`

### Endpoint

```
GET /seller/dashboard/products
```

### Purpose

* Show seller inventory

### Responsibilities

* Fetch seller products
* Stock, price, visibility

Uses:

* `product.model.js`

---

### Controller Golden Rule

Controllers:

* Accept `req`, `res`
* Call models
* Format response
* Handle errors

They **never**:

* Start servers
* Handle routing
* Parse tokens

---

# 6ï¸âƒ£ Model Layer (Data Shape Only)

## ğŸ“„ `src/models/*.model.js`

### Purpose

* Define MongoDB schemas
* Enforce structure

### Examples

* `order.model.js` â†’ orders
* `product.model.js` â†’ products
* `payment.model.js` â†’ transactions
* `user.model.js` â†’ sellers/users

### Important note

Models contain:

* No HTTP logic
* No business flow
* No request context

They are **passive**.

---

# 7ï¸âƒ£ Broker Layer (Async / Background)

This is **independent of HTTP**.

---

## ğŸ“„ `src/broker/broker.js`

### Purpose

* Abstract RabbitMQ logic

### Defines

* `connect()`
* `publishToQueue()`
* `subscribeToQueue()`

Controllers **may publish events**, but they never consume them.

---

## ğŸ“„ `src/broker/listener.js`

### Purpose

* Subscribe to queues
* React to async events

### Why it runs at startup

It contains **top-level `subscribeToQueue()` calls**, meaning:

```
import listener.js â†’ queues subscribed immediately
```

This is intentional for:

* Order updates
* Payment confirmations
* Inventory sync

---

# ğŸ” COMPLETE REQUEST FLOW (STEP-BY-STEP)

### Request

```
GET /seller/dashboard/products
```

### Flow

```
Client
  â†“
server.js (already running)
  â†“
app.js (Express receives request)
  â†“
seller.routes.js (URL matched)
  â†“
auth.middleware.js (JWT verified)
  â†“
seller.controller.js â†’ getProducts()
  â†“
product.model.js (DB query)
  â†“
Response JSON
```

---

# ğŸ§  Why this architecture is GOOD

âœ” Separation of concerns
âœ” Easy to test
âœ” Easy to scale
âœ” Easy to replace RabbitMQ / DB
âœ” Matches industry standards

This is **real production architecture**, not tutorial junk.

---

