# ðŸŒ± DOCKER + AWS ECS AI-BUDDY (SOCKET.IO) SERVICE â€” STEP-BY-STEP (EXPLAIN EACH)

## Make sure Docker and AWSCLI is installed properly

---

## `.dockerignore`

```

.env
node_modules

```

### What `.dockerignore` does
This file tells Docker which files and folders **must NOT be copied**
into the Docker image during the build process.

### Why each entry exists

- `.env`  
  Contains sensitive runtime data such as:
  - API keys
  - database URLs
  - AI service credentials  

  These values **must never be baked into a Docker image**.  
  In AWS ECS, environment variables are added **manually in the task definition**
  or via AWS Secrets Manager.

- `node_modules`  
  Node dependencies are OS-specific.  
  Your local machine may differ from ECS (Linux).  
  Therefore dependencies must be installed **inside the container**
  using `npm install`.

---

## `dockerfile`

```

FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3005

CMD ["npm", "start"]

```

### Explanation line by line

- `FROM node:18-alpine`  
  Uses Node.js version 18 on Alpine Linux.  
  Alpine is lightweight â†’ smaller image size â†’ faster startup â†’ lower memory usage.

- `WORKDIR /app`  
  Sets `/app` as the working directory inside the container.  
  All following commands run relative to this directory.

- `COPY package*.json ./`  
  Copies `package.json` and `package-lock.json` first.  
  This enables Docker layer caching so dependencies are not reinstalled
  unless these files change.

- `RUN npm install`  
  Installs all Node.js dependencies **inside the container environment**.

- `COPY . .`  
  Copies the entire project source code into the container,
  while respecting `.dockerignore`.

- `EXPOSE 3005`  
  Declares that the application listens on **port 3005**.

- `CMD ["npm", "start"]`  
  Defines the default command used when the container starts.

### IMPORTANT
Make sure your `package.json` contains:

```

"start": "node server.js"

```

This ensures consistent behavior across:
- local development
- Docker containers
- AWS ECS

---

## path based modifications in code

```

const io = new Server(httpServer, {
path: "/api/socket/socket.io/",
})

```

### Why this is important

- Socket.IO does **NOT** always work correctly behind an ALB using default paths
- ALB routing is **path-based**, so the socket handshake must match the ALB rule
- This custom path ensures:
  - clean routing
  - no conflict with REST APIs
  - predictable WebSocket upgrades

### What this path represents

- `/api/socket/socket.io/`
  - Used by the client during Socket.IO handshake
  - Must match ALB rule path exactly
  - Must be exposed through the correct target group

---

## making the page

- Turn ON **Docker Desktop**  
  Docker must be running before building images locally.

### Use this command to create image

```

docker buildx --platform linux/amd64 -t cohort-ms-ai-buddy-service . --load

```

### Explanation of the command

- `buildx` â†’ advanced Docker builder
- `--platform linux/amd64` â†’ required for AWS ECS compatibility
- `-t cohort-ms-ai-buddy-service` â†’ image name (tag omitted)
- `.` â†’ current directory as build context
- `--load` â†’ loads image into local Docker

### About `:latest`
`:latest` is **not required**.  
If no tag is specified, Docker implicitly treats it as `latest`.

---

## create a repo in ECR

### Steps in AWS Console

- Elastic Container Registry
- Create Repository
- Name it `cohort-ms-ai-buddy-service`
- Create

### From push commands

- First login command  
  Authenticates Docker with AWS ECR.

- Build done  
  Image already exists locally.

- Tag command  
  Modify name if needed  
  Keep it same as build: `cohort-ms-ai-buddy-service`.

- Push command  
  Pushes the image to the ECR repository.

---

## Go back to console.

### ECS setup

- Create cluster
- After creation
- Create new task
- Name the task

### IAM roles

- `ecsTaskRole`  
  Used by the running application.

- `ecsTaskExecutionRole`  
  Used to:
  - pull images from ECR
  - write logs to CloudWatch
  - read environment variables and secrets  

Both can be selected.

### Container configuration

- Name container
- Go to ECR repo and copy image URI
- Paste image URI
- Select port you are using for the service (3005)
- Port name can be `express-app`
- Add **all `.env` variables manually**
- Create task definition

---

## Deploy the task/service

- Set service name
- Select the cluster we created
- Capacity provider strategy
- Health check: 5 sec
- Use same VPC if needed

### Load balancer configuration

- Create an ALB or use existing
- Listen to the created target group for the project with `/` path  
  (rules can be added later)
- Create a new target group
- Use project port (3005)
- Set priority if required
- Modify path pattern if needed
- Create service

### Verification

- Go to EC2
- Check if the ALB has a listener
- Listener should forward traffic to the correct target group
- Copy the Domain name

### Usage

- Replace all `localhost:3005`
- Use the ALB domain in Axios and Socket.IO clients

---

## end work

### ALB routing refinement (VERY IMPORTANT FOR SOCKET.IO)

- Go to your ALB
- Edit rule of newly deployed service
- Change path from:

```

/

```

to:

```

/api/socket/socket.io

```

- Route this path to its own target group
- Target group must be the one created earlier for AI-Buddy service

### Debugging tip
If **Postman or frontend throws socket errors**:
- Check Socket.IO client handshake path
- Ensure it matches:
  - server `path`
  - ALB rule path
  - target group listener

---

## note

### If you get runtime error

- Fix the error locally
- Build the image again
- Push the updated image to ECR

### Force redeployment

- Go to ECS
- Clusters â†’ `your cluster`
- Services â†’ `your service`
- Health
- Click **Force new deployment**

This pulls the updated image and restarts the service.

---