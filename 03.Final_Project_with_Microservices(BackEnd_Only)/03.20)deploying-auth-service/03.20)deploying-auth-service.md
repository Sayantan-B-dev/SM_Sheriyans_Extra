
# ðŸŒ± DOCKER + AWS ECS AUTH SERVICE â€” STEP-BY-STEP (EXPLAIN EACH)

## Make sure Docker and AWSCLI is installed properly

## `.dockerignore`


```
.env
node_modules
```

### What `.dockerignore` does
This file tells Docker **what NOT to copy** into the image while building.

### Why each line exists

- `.env`  
  This file contains sensitive data such as:
  - JWT secrets
  - database URIs
  - API keys  

  These **must never be baked into a Docker image**.  
  In ECS, environment variables are added manually or via secrets manager.

- `node_modules`  
  Node modules are platform-specific.  
  Since ECS runs on Linux, dependencies should be installed **inside the container**, not copied from your local machine.

---

## `dockerfile`

```
FROM node:18-alpine

WORKDIR /app


COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
```

### Explanation line by line

- `FROM node:18-alpine`  
  Uses Node.js version 18 with Alpine Linux.  
  Alpine is lightweight â†’ smaller image size â†’ faster startup.

- `WORKDIR /app`  
  Sets `/app` as the working directory inside the container.  
  All following commands run relative to this folder.

- `COPY package*.json ./`  
  Copies only `package.json` and `package-lock.json`.  
  This enables Docker layer caching so dependencies are not reinstalled every time.

- `RUN npm install`  
  Installs all Node.js dependencies **inside the container**.

- `COPY . .`  
  Copies the rest of the project files into the container,  
  while respecting `.dockerignore`.

- `EXPOSE 3000`  
  Declares that the application listens on port 3000.

- `CMD ["npm", "start"]`  
  Tells Docker how to start the app when the container runs.

### IMPORTANT
Make sure your `package.json` has this script:

```
"start": "node server.js"
```

---

## making the page

- Turn on **Docker Desktop**
- This is mandatory before building images locally

### Use this command to create image

```
docker buildx --platform linux/amd64 -t cohort-ms-auth-service:latest . --load
```

### What this command does

- `buildx` â†’ modern Docker builder
- `--platform linux/amd64` â†’ required for AWS ECS compatibility
- `-t cohort-ms-auth-service:latest` â†’ image name and tag
- `.` â†’ build context (current directory)
- `--load` â†’ loads image into local Docker after build

---

## create a repo in ECR

Steps in AWS Console:

- Elastic Container Registry
- Create Repository
- Name it `cohort-ms/auth-service`
- Create

### From push commands

- First login command  
  Logs Docker into AWS ECR

- Build done  
  (Image already built locally)

- Tag command  
  Modify the name if needed  
  Keep it same as build: `cohort-ms-auth-service`

- Push command  
  Pushes the image to ECR repository

---

## Go back to console.

### ECS setup

- Create cluster
- After creation
- Create new task
- Name the task

### IAM roles

- `ecsTaskRole` â†’ application permissions
- `ecsTaskExecutionRole` â†’ image pull, logs, secrets  
  Both can be selected

### Container configuration

- Name container
- Go to ECR repo and copy image URI
- Paste image URI
- Select port you are using for the service
- Port name can be `express-app`
- Add **all `.env` variables manually**
- Create task definition

---

## Deploy the task/service

- Set service name
- Select the cluster we created
- Capacity provider strategy
- Health check: 5 sec
- Use same VPC if needed

### Load balancer

- Create an ALB or use existing
- Create a new target group or use existing
- Path pattern can be modified here if needed
- Create service

### Verification

- Go to EC2
- Check if the ALB has a listener
- Listener should forward to the target group
- Copy the Domain name

### Usage

- Use this domain for other services
- Replace all `localhost:3000` used by Axios

---

## important

### Security group configuration

- Go to EC2 from console
- Security Groups
- Select the group
- Edit inbound rule

### Add these rules (source = same security group)

- Custom TCP, port number 3001
- Custom TCP, port number 3002
- Custom TCP, port number 3003
- Custom TCP, port number 3004
- Custom TCP, port number 3005
- Custom TCP, port number 3006
- Custom TCP, port number 3007

### Why this is required

- Allows **internal microservice communication**
- Prevents public internet exposure
- Keeps services isolated but connected

---

