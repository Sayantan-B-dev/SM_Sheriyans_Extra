# `src/app.js`

```
APPLICATION BOOTSTRAP & ROUTING ALGORITHM:
→ import express (require)
     - `require()` loads a module and returns its exports (CommonJS).
→ import cookieParser middleware
     - cookieParser() parses cookies on incoming requests and populates req.cookies.
→ import sellerRoutes (router module)
→ create app = express()
     - express() returns an application instance with routing, middleware methods.
→ app.use(express.json())
     - registers middleware to parse JSON bodies (body-parser built-in).
→ app.use(cookieParser())
     - registers cookie parser middleware.
→ register health endpoint GET "/"
     - app.get(path, handler)
     - handler receives (req, res)
     - res.status(200) sets HTTP status; res.json sends JSON response.
→ mount seller routes under "/api/seller/dashboard"
     - app.use(path, router)
     - this composes routers (mounting).
→ module.exports = app
     - exports the app instance so server script can import it.
```

Syntax notes:

* `require('module')`: CommonJS import.
* `app.use(middleware)`: middleware pipeline; order matters.
* `app.get(path, handler)`: registers route; handler is function(req, res).
* `module.exports`: object exported by module for other files to `require()`.

---

# `src/broker/broker.js`

```
BROKER CONNECT FUNCTION (connect) ALGORITHM:
→ function connect() defined as async
     - `async` marks function that returns a Promise.
     - `await` can be used inside to pause until Promise resolves.
→ if connection exists:
     - return cached connection (singleton pattern prevents multiple connections).
→ try:
     → call amqplib.connect(RABBIT_URL)
          - creates TCP connection to RabbitMQ, returns a Promise.
          - await pauses until resolved.
     → on success, create channel via connection.createChannel()
          - channel: lightweight multiplexed session for publishing/consuming.
     → store connection and channel in module scope variables.
     → log "Connected to RabbitMQ".
→ catch:
     - handle and log connection errors.
     - do not throw unhandled — prevents immediate crash (but consider retry in production).

SYNTAX EXPLANATIONS:
- `async/await`: syntactic sugar over Promises; `await` unwraps Promise result.
- `try/catch` around await: required to catch rejections.
- Module-scoped `let channel, connection`: shared state between functions in same module.
```

```
PUBLISH TO QUEUE FUNCTION (publishToQueue) ALGORITHM:
→ function publishToQueue(queueName, data = {}) is async
→ if channel or connection not ready:
     - call connect() to lazily initialize broker connection.
→ channel.assertQueue(queueName, { durable: true })
     - ensures queue exists; durable=true persists queue across broker restarts.
→ serialize payload: JSON.stringify(data)
→ convert to binary: Buffer.from(serializedData)
     - RabbitMQ expects binary payloads.
→ channel.sendToQueue(queueName, buffer)
     - enqueues message; it's fire-and-forget by default.
→ console.log confirmation

SYNTAX EXPLANATIONS:
- `assertQueue`: idempotent – safe to call repeatedly.
- `Buffer.from()`: Node buffer creation for binary payload.
- `sendToQueue`: synchronous API that queues message; reliability depends on channel/confirm mode.
```

```
SUBSCRIBE TO QUEUE FUNCTION (subscribeToQueue) ALGORITHM:
→ function subscribeToQueue(queueName, callback) is async
→ ensure connection/channel via connect() if not ready
→ channel.assertQueue(queueName, { durable: true })
→ channel.consume(queueName, handler)
     - handler invoked with `msg` for each delivery
→ handler:
     → if msg is not null:
          → read payload: msg.content.toString()
          → parse JSON: JSON.parse(string)
          → await callback(parsedData)
               - callback is user-provided async function handling business logic
          → channel.ack(msg)
               - acknowledges message; removes it from queue
→ no explicit return needed (consumer runs continuously)

SYNTAX EXPLANATIONS:
- `channel.consume(queue, handler)`: registers long-lived consumer.
- `msg.content` is a Buffer; `.toString()` converts to string.
- `channel.ack(msg)`: manual acknowledgement pattern; prevents re-delivery only after successful processing.
- `await callback(...)`: allows asynchronous handlers (DB writes, HTTP calls).
```

```
MODULE EXPORTS:
→ export { connect, channel, connection, publishToQueue, subscribeToQueue } via module.exports
     - exposes functions and references to other modules
```

Notes:

* Consider connection error handling and reconnect/backoff in production.
* Exposing `channel` and `connection` directly is convenient but can be brittle if reassigned.

---

# `src/broker/listener.js`

```
LISTENER INITIALIZER ALGORITHM (module.exports = async function()):
→ import subscribeToQueue() from broker module
→ import models: userModel, productModel, orderModel, paymentModel
→ register subscriptions for each topic with subscribeToQueue(topic, handler)
     - each handler is async and performs DB writes
→ topics and handlers:
     → "AUTH_SELLER_DASHBOARD.USER_CREATED":
          → handler(user):
               → await userModel.create(user)
               → writes user document to MongoDB
     → "PRODUCT_SELLER_DASHBOARD.PRODUCT_CREATED":
          → handler(product):
               → await productModel.create(product)
     → "ORDER_SELLER_DASHBOARD.ORDER_CREATED":
          → handler(order):
               → await orderModel.create(order)
     → "PAYMENT_SELLER_DASHBOARD.PAYMENT_CREATED":
          → handler(payment):
               → await paymentModel.create(payment)
     → "PAYMENT_SELLER_DASHBOARD.PAYMENT_UPDATE":
          → handler(payment):
               → await paymentModel.findOneAndUpdate({ orderId: payment.orderId }, { ...payment })
               → updates existing payment by orderId (upsert or not depends on options; here it's a straight update)

SYNTAX & FUNCTION NOTES:
- `subscribeToQueue(topic, async (payload) => { ... })`:
     - callback is an async arrow function; `async` allows `await` inside.
- `Model.create(obj)`:
     - Mongoose helper to construct & save document in one call.
- `Model.findOneAndUpdate(filter, update)`:
     - finds document matching filter and applies update atomically.
- Module exports an async initializer function so external startup code can `await` it if needed.
```

Operational notes:

* Handlers should validate payload shape before DB writes (not shown here).
* Consider idempotency: if same event replays, duplicates may be created; include unique keys or dedupe logic.

---

# `src/controllers/seller.controller.js`

```
GET METRICS FUNCTION ALGORITHM (getMetrics):
→ function defined as async (req, res)
→ inside try/catch
     → extract seller = req.user (set by auth middleware)
     → retrieve seller products:
          → products = await productModel.find({ seller: seller._id })
               - `find()` returns array of documents
     → get productIds = products.map(p => p._id)
     → query orders containing these products:
          → orders = await orderModel.find({
                'items.product': { $in: productIds },
                status: { $in: ["CONFIRMED","SHIPPED","DELIVERED"] }
            })
               - `$in` operator matches any product in productIds
     → initialize aggregators: sales = 0, revenue = 0, productSales = {}
     → iterate orders:
          → for each order:
               → for each item in order.items:
                    → if productIds includes item.product:
                         → sales += item.quantity
                         → revenue += item.price.amount * item.quantity
                         → productSales[item.product] = (existing || 0) + item.quantity
     → compute topProducts:
          → Object.entries(productSales) returns array [ [productId, qty], ... ]
          → .sort comparator (b, a) to sort descending by qty
               - comparator receives two entries and returns positive/negative to order
          → .slice(0,5) keep top 5
          → .map(([productId, qty]) => find matching product in `products` by id and return {id, title, sold}
               - uses `prod._id.equals(productId)` to compare ObjectIds
          → .filter(Boolean) removes nulls
     → return JSON { sales, revenue, topProducts } via res.json()
→ catch errors:
     → log error and return res.status(500).json({ message: "Internal Server Error" })

SYNTAX & FUNCTION NOTES:
- `await productModel.find(filter)`: Mongoose query returns Promise.
- `Array.map`, `Array.forEach`: synchronous array iteration methods.
- `productIds.includes(item.product)`:
     - NOTE: if item.product is an ObjectId, `includes` comparing by reference may fail unless they are same type; safer to convert to strings or use `.equals()` (code uses includes but production should normalize types).
- `Object.entries(obj)`: converts object map to array of [key, value] pairs.
- `.sort((a,b) => b[1] - a[1])`: comparator sorts numeric values descending.
- `prod._id.equals(productId)`: Mongoose ObjectId `.equals` method compares IDs reliably.
- `.filter(Boolean)`: removes null/undefined from array.
```

```
GET ORDERS FUNCTION ALGORITHM (getOrders):
→ async function (req, res)
→ try:
     → seller = req.user
     → products = await productModel.find({ seller: seller._id })
     → productIds = products.map(p => p._id)
     → orders = await orderModel.find({ 'items.product': { $in: productIds } })
           .populate('user', 'name email')
           .sort({ createdAt: -1 })
          - `.populate(field, select)` replaces referenced user ObjectId with user doc limited to name & email
     → map orders to filteredOrders:
          → for each order:
               → filteredItems = order.items.filter(item => productIds.includes(item.product))
               → return { ...order.toObject(), items: filteredItems }
          → filter out orders where filteredItems.length == 0
     → res.json(filteredOrders)
→ catch: log error & 500 response

SYNTAX NOTES:
- `.populate()` lets Mongoose perform a join-like lookup for refs.
- `.sort({ createdAt: -1 })` sorts descending by createdAt timestamp.
- `order.toObject()` converts Mongoose doc to plain JS object for safe spreading.
```

```
GET PRODUCTS FUNCTION ALGORITHM (getProducts):
→ async function (req, res)
→ try:
     → seller = req.user
     → products = await productModel.find({ seller: seller._id }).sort({ createdAt: -1 })
     → res.json(products)
→ catch: log error & 500 response

SYNTAX NOTES:
- `find().sort()` chaining: Mongoose Query API returns Promise when awaited.
- Sorting by createdAt requires timestamps option on schema (orders had timestamps; products depend on model).
```

Operational considerations:

* Ensure `req.user` contains `_id` (auth middleware should attach it).
* Consider pagination for orders/products in large datasets.
* For revenue calculation, beware of currency mixing—ensure consistent currency or convert.

---

# `src/db/db.js`

```
MONGODB CONNECT FUNCTION ALGORITHM (connectDB):
→ async function connectDB()
→ try:
     → await mongoose.connect(process.env.MONGO_URI)
          - mongoose.connect() returns a Promise that resolves when connected
     → console.log "Connected to MongoDB"
→ catch (error):
     → log error
     → process.exit(1) to fail-fast (stop process on DB connection failure)

SYNTAX NOTES:
- `mongoose.connect(uri)` handles connection pooling & internal reconnection logic.
- `process.exit(1)` exits node with non-zero code indicating failure.
```

Notes:

* In production prefer retry/backoff and not immediate exit, unless service must not run without DB.

---

# `src/middlewares/auth.middleware.js`

```
CREATE AUTH MIDDLEWARE FACTORY ALGORITHM (createAuthMiddleware):
→ function createAuthMiddleware(roles = ["user"])
     - returns a middleware function (closure capturing roles)
     - pattern: middleware factory for role-based access control

→ returned authMiddleware(req, res, next):
     → extract token:
          - from cookie: req.cookies?.token (optional chaining)
          - OR from header: req.headers?.authorization?.split(' ')[1]
               - Authorization header format: "Bearer <token>"
               - `.split(' ')[1]` extracts token part
     → if no token:
          → return res.status(401).json({ message: 'Unauthorized: No token provided' })
     → try:
          → const decoded = jwt.verify(token, process.env.JWT_SECRET)
               - verifies signature and decodes payload; throws on invalid/expired token
          → if decoded.role not in roles:
               → return res.status(403).json({ message: 'Forbidden: Insufficient permissions' })
          → req.user = decoded (attach user info to request)
          → call next() to proceed to route handler
     → catch (err):
          → return res.status(401).json({ message: 'Unauthorized: Invalid token' })

SYNTAX & FUNCTION NOTES:
- Middleware signature: (req, res, next) — `next` is function to call next middleware/handler.
- `createAuthMiddleware` is factory returning middleware — common pattern for parametrized middleware.
- Optional chaining `req.cookies?.token` prevents exceptions when `cookies` is undefined.
- `jwt.verify(token, secret)` throws on invalid token; wrap in try/catch.
- `res.status(code).json(obj)` sets HTTP status and sends JSON.
```

Security notes:

* Consider token expiry handling and refresh token flows.
* Beware that splitting Authorization header without validation can throw if header absent — optional chaining used here helps but production code should be defensive.

---

# `src/models/order.model.js`

```
ORDER MODEL SCHEMA ALGORITHM:
→ define addressSchema with fields: street, city, state, zip, country
     - subdocument schema for shippingAddress
→ define orderSchema:
     → user: ObjectId ref, required
     → items: array of item subdocuments:
          - product: ObjectId required
          - quantity: Number default 1, min 1
          - price: embedded doc { amount: Number required, currency: String required, enum: ["USD","INR"] }
     → status: String enum [ "PENDING","CONFIRMED","CANCELLED","SHIPPED","DELIVERED" ]
     → totalPrice: { amount: Number required, currency: String enum ["USD","INR"] }
     → shippingAddress: addressSchema required
     → timestamps: true option on schema (createdAt, updatedAt auto-managed)
→ create model: mongoose.model("order", orderSchema)
→ export model

SCHEMA & SYNTAX NOTES:
- `new mongoose.Schema({...}, { timestamps: true })` auto adds createdAt & updatedAt.
- `type: mongoose.Schema.Types.ObjectId` stores references to other docs.
- `enum` enforces allowed string values at schema validation.
- `min` and `default` enforce numeric constraints & default values.
- Model name "order" used to create collection (Mongoose pluralizes to "orders").
```

Design notes:

* Indexes (e.g., on user or status) may speed queries.
* Consider schema versioning for future changes.

---

# `src/models/payment.model.js`

```
PAYMENT MODEL SCHEMA ALGORITHM:
→ define paymentSchema:
     → order: ObjectId required (reference to order)
     → paymentId: String (gateway id)
     → razorpayOrderId: String required
     → signature: String
     → status: enum ['PENDING','COMPLETED','FAILED'] default 'PENDING'
     → user: ObjectId required
     → price: { amount: Number required, currency: String default 'INR', enum: ['INR','USD'] }
     → timestamps: true
→ create model: mongoose.model('payment', paymentSchema)
→ export paymentModel

SYNTAX NOTES:
- `default` sets default field value if omitted on create.
- Enums used for status and currency to validate allowed values.
```

Operational notes:

* For payment reconciliation, add unique constraints for paymentId/razorpayOrderId to avoid duplicates.

---

# `src/models/product.model.js`

```
PRODUCT MODEL SCHEMA ALGORITHM:
→ define productSchema:
     → title: String required
     → description: String optional
     → price: { amount: Number required, currency: enum ['USD','INR'], default 'INR' }
     → seller: ObjectId required
     → images: array of { url, thumbnail, id } objects
     → stock: Number default 0
→ add text index: productSchema.index({ title: 'text', description: 'text' })
     - enables MongoDB text search over title and description
→ create and export model: mongoose.model('product', productSchema)

SYNTAX NOTES:
- `schema.index()` creates DB index; text indexes allow `$text` searches.
- `images` as array of subdocuments for media metadata.
```

Considerations:

* Add SKU, category, availability flags for richer catalogs.
* Consider compound indexes for seller+createdAt for efficient seller queries.

---

# `src/models/user.model.js`

```
USER MODEL SCHEMA ALGORITHM:
→ define addressSchema:
     → street, city, state, zip, country
     → isDefault: Boolean default false
→ define userSchema:
     → username: String required unique
     → email: String required unique
     → password: String select: false
          - `select: false` ensures `password` excluded by default in queries (needs explicit .select('+password') to include)
     → fullName: { firstName required, lastName required }
     → role: enum ['user','seller'] default 'user'
     → addresses: [ addressSchema ]
→ create model: mongoose.model('user', userSchema)
→ export model

SYNTAX & SECURITY NOTES:
- `unique: true` creates unique index at DB level (enforced by MongoDB).
- `select: false` hides sensitive fields by default which is a good practice.
- For password storage: hash using bcrypt before saving (not shown in model file but expected in auth flow).
```

Operational notes:

* Ensure unique index creation is synced with DB migrations.
* Consider email normalization and validation at schema or application layer.

---

# `src/routes/seller.routes.js`

```
SELLER ROUTES ALGORITHM:
→ import express.Router()
→ import createAuthMiddleware factory
→ import controller (getMetrics, getOrders, getProducts)
→ create router = express.Router()

→ route registrations:
     → GET "/metrics":
          → handler = createAuthMiddleware([ "seller" ], controller.getMetrics)
               - `createAuthMiddleware(roles, handler)` pattern: some codebases accept handler as next param; here assumption is factory returns middleware and route uses controller separately. If createAuthMiddleware returns middleware only, route should be: router.get("/metrics", createAuthMiddleware(["seller"]), controller.getMetrics)
          → purpose: protect route to only seller role
     → GET "/orders":
          → protected by seller role middleware, calls controller.getOrders
     → GET "/products":
          → protected by seller role middleware, calls controller.getProducts

→ module.exports = router

SYNTAX EXPLANATIONS:
- `express.Router()` returns a mini-router; helps modularize routes.
- `router.get(path, middleware, handler)` accepts one or more middleware before final handler.
- `module.exports = router` exposes the router to be mounted by app.use().
```

Note on middleware usage:

* Ensure createAuthMiddleware is used correctly: if it returns middleware, pass it as a separate argument before controller.

---

# Final notes & quick checklist (practical)

```
→ Verify token extraction logic handles missing Authorization header safely.
→ Ensure ObjectId comparisons use .equals() or convert to string to avoid false negatives.
→ Add input validation (Zod/Joi) for queue payloads and route inputs.
→ Add index on frequently queried fields (e.g., product.seller, order.createdAt).
→ Add idempotency and deduplication for listeners (use unique keys).
→ Add retry/backoff and DLQ patterns for RabbitMQ consumers.
→ Add logging + monitoring for message processing failures.
→ Consider pagination for orders/products endpoints.
```

---