Perfect â€” understood ðŸ‘
Below is **pure algorithmic documentation**, **NO real code**, written exactly in the **style you asked**.

âœ” Each section
âœ” File name on top
âœ” Every function broken into **step-by-step algorithm**
âœ” Structured, readable, production-grade
âœ” Mirrors **your exact implementation**

---

# `src/app.js`

### APPLICATION BOOTSTRAP ALGORITHM

```
â†’ import express
â†’ import cookie-parser
â†’ import productRoutes

â†’ create express app instance

â†’ enable JSON body parsing
â†’ enable cookie parsing

â†’ define GET / route
   â†’ return 200
   â†’ respond with service health message

â†’ mount productRoutes at /api/products

â†’ export app instance
```

---

# `src/db/db.js`

### CONNECT DATABASE ALGORITHM

```
â†’ import mongoose

â†’ define connectDB function
   â†’ try connecting to MongoDB using MONGO_URI
   â†’ if connection succeeds:
       â†’ log "MongoDB connected"
   â†’ if connection fails:
       â†’ log error
       â†’ do not crash process (graceful failure)

â†’ export connectDB function
```

---

# `src/broker/borker.js`

### CONNECT TO MESSAGE BROKER ALGORITHM

```
â†’ import amqplib

â†’ maintain global connection and channel variables

â†’ define connect function
   â†’ if connection already exists:
       â†’ return existing connection
   â†’ else:
       â†’ connect to RabbitMQ using RABBIT_URL
       â†’ create channel
       â†’ store connection and channel
       â†’ log success
   â†’ on error:
       â†’ log failure
```

---

### PUBLISH TO QUEUE ALGORITHM

```
â†’ accept queueName and data

â†’ if channel or connection not initialized:
     â†’ call connect()

â†’ assert queue (durable)

â†’ convert data to JSON buffer

â†’ send message to queue

â†’ log queue name and payload
```

---

### SUBSCRIBE TO QUEUE ALGORITHM

```
â†’ accept queueName and callback

â†’ if channel or connection not initialized:
     â†’ call connect()

â†’ assert queue (durable)

â†’ consume messages from queue
   â†’ for each message:
       â†’ parse JSON data
       â†’ execute callback(data)
       â†’ acknowledge message
```

---

# `src/middlewares/auth.middleware.js`

### ROLE-BASED AUTHENTICATION ALGORITHM

```
â†’ accept allowed roles (default: ['user'])

â†’ return middleware function

â†’ extract token from:
     â†’ cookies.token OR
     â†’ Authorization header (Bearer token)

â†’ if token not present:
     â†’ return 401 Unauthorized

â†’ verify token using JWT_SECRET
   â†’ if verification fails:
       â†’ return 401 Invalid token

â†’ extract decoded user payload

â†’ check if decoded.role exists in allowed roles
   â†’ if not:
       â†’ return 403 Forbidden

â†’ attach decoded user to req.user

â†’ call next()
```

---

# `src/models/product.model.js`

### PRODUCT SCHEMA DESIGN ALGORITHM

```
â†’ define product schema with fields:
   â†’ title (string, required)
   â†’ description (string, optional)
   â†’ price object:
       â†’ amount (number, required)
       â†’ currency (enum: USD, INR)
   â†’ seller (ObjectId, required)
   â†’ images array:
       â†’ url
       â†’ thumbnail
       â†’ id
   â†’ stock (number, default 0)

â†’ enable text index on:
   â†’ title
   â†’ description

â†’ export Product model
```

---

# `src/routes/product.routes.js`

### ROUTE REGISTRATION ALGORITHM

```
â†’ import express router
â†’ configure multer with memory storage

â†’ POST /api/products
   â†’ authenticate roles: admin, seller
   â†’ parse multipart images (max 5)
   â†’ validate request body
   â†’ call createProduct controller

â†’ GET /api/products
   â†’ public access
   â†’ call getProducts controller

â†’ PATCH /api/products/:id
   â†’ authenticate seller
   â†’ call updateProduct controller

â†’ DELETE /api/products/:id
   â†’ authenticate seller
   â†’ call deleteProduct controller

â†’ GET /api/products/seller
   â†’ authenticate seller
   â†’ call getProductsBySeller controller

â†’ GET /api/products/:id
   â†’ public access
   â†’ call getProductById controller
```

---

# `src/controllers/product.controller.js`

---

### CREATE PRODUCT ALGORITHM

```
â†’ extract title, description, priceAmount, priceCurrency from req.body
â†’ extract sellerId from req.user.id

â†’ construct price object:
   â†’ convert priceAmount to Number
   â†’ assign currency (default INR)

â†’ process uploaded files:
   â†’ for each file buffer:
       â†’ upload to ImageKit
       â†’ collect returned image metadata

â†’ create product in database with:
   â†’ title
   â†’ description
   â†’ price
   â†’ seller
   â†’ images

â†’ publish PRODUCT_CREATED event to:
   â†’ seller dashboard queue
   â†’ notification queue (email + productId)

â†’ return 201 Created with product data

â†’ on error:
   â†’ log error
   â†’ return 500 Internal Server Error
```

---

### GET PRODUCTS ALGORITHM

```
â†’ extract query params:
   â†’ q (search)
   â†’ minprice
   â†’ maxprice
   â†’ skip
   â†’ limit

â†’ initialize empty filter object

â†’ if search query exists:
   â†’ apply $text search

â†’ if minprice exists:
   â†’ apply $gte filter on price.amount

â†’ if maxprice exists:
   â†’ apply $lte filter on price.amount

â†’ query database:
   â†’ apply filters
   â†’ apply pagination
   â†’ cap limit at 20

â†’ return 200 with product list
```

---

### GET PRODUCT BY ID ALGORITHM

```
â†’ extract product id from params

â†’ validate ObjectId
   â†’ if invalid:
       â†’ return 400

â†’ find product by id

â†’ if not found:
   â†’ return 404

â†’ return 200 with product data
```

---

### UPDATE PRODUCT ALGORITHM

```
â†’ extract product id

â†’ validate ObjectId
   â†’ if invalid:
       â†’ return 400

â†’ fetch product from database

â†’ if not found:
   â†’ return 404

â†’ verify ownership:
   â†’ if product.seller !== req.user.id:
       â†’ return 403 Forbidden

â†’ define allowed update fields:
   â†’ title
   â†’ description
   â†’ price

â†’ iterate over request body keys
   â†’ update allowed fields only
   â†’ handle price.amount and price.currency separately

â†’ save updated product

â†’ return 200 with updated product
```

---

### DELETE PRODUCT ALGORITHM

```
â†’ extract product id

â†’ validate ObjectId
   â†’ if invalid:
       â†’ return 400

â†’ find product

â†’ if not found:
   â†’ return 404

â†’ verify ownership
   â†’ if not owner:
       â†’ return 403

â†’ delete product from database

â†’ return 200 with success message
```

---

### GET PRODUCTS BY SELLER ALGORITHM

```
â†’ extract seller from req.user

â†’ extract pagination params

â†’ query products where:
   â†’ seller equals req.user.id

â†’ apply pagination
â†’ limit max results to 20

â†’ return 200 with seller's products
```

---

# `src/services/imagekit.service.js`

### IMAGE UPLOAD ALGORITHM

```
â†’ accept image buffer and optional folder

â†’ generate unique filename using UUID

â†’ upload buffer to ImageKit:
   â†’ file
   â†’ fileName
   â†’ folder

â†’ extract upload response

â†’ return standardized object:
   â†’ url
   â†’ thumbnailUrl (fallback to url)
   â†’ fileId
```

---

# `src/validators/product.validators.js`

### CREATE PRODUCT VALIDATION ALGORITHM

```
â†’ validate title:
   â†’ must be string
   â†’ must not be empty

â†’ validate description (optional):
   â†’ must be string
   â†’ max length 500

â†’ validate priceAmount:
   â†’ must exist
   â†’ must be number > 0

â†’ validate priceCurrency (optional):
   â†’ must be USD or INR

â†’ collect validation errors

â†’ if errors exist:
   â†’ return 400 with error list

â†’ else:
   â†’ call next()
```

---

# `tests/fixtures/sample.jpg`

### TEST FIXTURE USAGE ALGORITHM

```
â†’ store a dummy binary file
â†’ file is not opened or parsed
â†’ file is streamed as multipart/form-data
â†’ used only to simulate image upload in tests
â†’ content does not matter, only presence matters
```

---

# `tests/product.post.test.js`

### TEST SUITE: CREATE PRODUCT (POST /api/products)

---

### GLOBAL TEST SETUP ALGORITHM

```
â†’ create in-memory MongoDB server
â†’ set MONGO_URI to memory server URI
â†’ set JWT_SECRET for test environment
â†’ connect mongoose to in-memory database
```

---

### GLOBAL TEST TEARDOWN ALGORITHM

```
â†’ drop test database
â†’ close mongoose connection
â†’ stop in-memory MongoDB server
```

---

### AFTER EACH TEST CLEANUP ALGORITHM

```
â†’ fetch all MongoDB collections
â†’ delete all documents from each collection
```

---

### TEST: CREATE PRODUCT WITH IMAGE UPLOAD

```
â†’ generate JWT token with:
   â†’ random user id
   â†’ role = seller

â†’ send POST /api/products request
   â†’ attach Authorization Bearer token
   â†’ attach form fields:
       â†’ title
       â†’ description
       â†’ priceAmount
       â†’ priceCurrency
   â†’ attach image file (sample.jpg)

â†’ expect response status = 201
â†’ expect response body contains:
   â†’ product title
   â†’ numeric price amount
   â†’ images array length = 1
   â†’ image URL contains mocked ImageKit URL
```

---

### TEST: VALIDATION FAILURE WHEN REQUIRED FIELDS MISSING

```
â†’ generate JWT token with seller role

â†’ send POST /api/products request
   â†’ only provide title
   â†’ omit priceAmount

â†’ expect response status = 400
â†’ expect validation error response
```

---

# `tests/product.get.test.js`

### TEST SUITE: LIST PRODUCTS (GET /api/products)

---

### SETUP ALGORITHM

```
â†’ start in-memory MongoDB
â†’ connect mongoose
â†’ sync text indexes for Product model
```

---

### TEST: EMPTY PRODUCT LIST

```
â†’ ensure no products exist

â†’ send GET /api/products

â†’ expect status = 200
â†’ expect data to be an empty array
```

---

### TEST: RETURN ALL PRODUCTS

```
â†’ insert multiple products into database

â†’ send GET /api/products

â†’ expect status = 200
â†’ expect returned list length equals inserted count
```

---

### TEST: TEXT SEARCH USING q PARAMETER

```
â†’ insert products with different titles/descriptions

â†’ send GET /api/products?q=shirt

â†’ expect status = 200
â†’ expect only matching products returned
â†’ ensure unrelated products excluded
```

---

### TEST: PRICE RANGE FILTERING

```
â†’ insert products with different price amounts

â†’ send GET with:
   â†’ minprice only
â†’ expect only products >= minprice

â†’ send GET with:
   â†’ maxprice only
â†’ expect only products <= maxprice

â†’ send GET with:
   â†’ minprice + maxprice
â†’ expect products within range
```

---

### TEST: PAGINATION SUPPORT

```
â†’ insert multiple products

â†’ send GET with limit=2
â†’ expect 2 products

â†’ send GET with skip=2, limit=2
â†’ expect next 2 products

â†’ send GET with skip beyond count
â†’ expect remaining products only
```

---

# `tests/product.getById.test.js`

### TEST SUITE: GET PRODUCT BY ID

---

### TEST: INVALID OBJECT ID

```
â†’ send GET /api/products/{invalid-id}

â†’ expect status = 400
â†’ expect error message indicating invalid product id
```

---

### TEST: PRODUCT NOT FOUND

```
â†’ generate valid ObjectId that does not exist

â†’ send GET /api/products/{id}

â†’ expect status = 404
â†’ expect not found message
```

---

### TEST: PRODUCT FOUND

```
â†’ create product in database

â†’ send GET /api/products/{product-id}

â†’ expect status = 200
â†’ expect returned product id matches
â†’ expect correct product title
```

---

# `tests/product.patch.test.js`

### TEST SUITE: UPDATE PRODUCT (PATCH /api/products/:id)

---

### TEST: UNAUTHENTICATED REQUEST

```
â†’ create product

â†’ send PATCH request without token

â†’ expect status = 401
```

---

### TEST: NON-SELLER ROLE

```
â†’ create product
â†’ generate JWT with role = user

â†’ send PATCH request

â†’ expect status = 403
```

---

### TEST: INVALID PRODUCT ID

```
â†’ generate seller JWT

â†’ send PATCH with invalid product id

â†’ expect status = 400
```

---

### TEST: PRODUCT NOT FOUND

```
â†’ generate valid ObjectId not in database

â†’ send PATCH request

â†’ expect status = 404
```

---

### TEST: FORBIDDEN UPDATE (WRONG SELLER)

```
â†’ create product owned by seller B
â†’ authenticate as seller A

â†’ send PATCH request

â†’ expect status = 403
```

---

### TEST: SUCCESSFUL UPDATE

```
â†’ create product owned by authenticated seller

â†’ send PATCH request with:
   â†’ new title
   â†’ new description
   â†’ new price object

â†’ expect status = 200
â†’ expect updated fields reflect new values
```

---

# `tests/product.delete.test.js`

### TEST SUITE: DELETE PRODUCT (DELETE /api/products/:id)

---

### TEST: UNAUTHENTICATED DELETE

```
â†’ create product

â†’ send DELETE request without token

â†’ expect status = 401
```

---

### TEST: NON-SELLER ROLE

```
â†’ create product
â†’ authenticate with role = user

â†’ send DELETE request

â†’ expect status = 403
```

---

### TEST: INVALID PRODUCT ID

```
â†’ authenticate as seller

â†’ send DELETE with invalid id

â†’ expect status = 400
```

---

### TEST: PRODUCT NOT FOUND

```
â†’ authenticate as seller
â†’ send DELETE with non-existing id

â†’ expect status = 404
```

---

### TEST: FORBIDDEN DELETE (WRONG SELLER)

```
â†’ create product owned by seller B
â†’ authenticate as seller A

â†’ send DELETE request

â†’ expect status = 403
```

---

### TEST: SUCCESSFUL DELETE

```
â†’ create product owned by authenticated seller

â†’ send DELETE request

â†’ expect status = 200
â†’ verify product no longer exists in database
```

---

# `tests/product.seller.get.test.js`

### TEST SUITE: GET PRODUCTS BY SELLER

---

### TEST: UNAUTHENTICATED ACCESS

```
â†’ send GET /api/products/seller without token

â†’ expect status = 401
```

---

### TEST: NON-SELLER ROLE

```
â†’ authenticate with role = user

â†’ send GET /api/products/seller

â†’ expect status = 403
```

---

### TEST: RETURN ONLY AUTHENTICATED SELLER PRODUCTS

```
â†’ create products for seller A
â†’ create products for seller B

â†’ authenticate as seller A

â†’ send GET /api/products/seller

â†’ expect only seller A products returned
```

---

### TEST: PAGINATION FOR SELLER PRODUCTS

```
â†’ create multiple products for seller

â†’ send GET with limit
â†’ expect limited results

â†’ send GET with skip + limit
â†’ expect next batch of products
```

---