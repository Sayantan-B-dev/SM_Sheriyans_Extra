# `src/app.js`

### APPLICATION BOOTSTRAP ALGORITHM

```
→ import express
→ import cookie-parser
→ import productRoutes

→ create express app instance

→ enable JSON body parsing
→ enable cookie parsing

→ define GET / route
   → return 200
   → respond with service health message

→ mount productRoutes at /api/products

→ export app instance
```

---

# `src/db/db.js`

### CONNECT DATABASE ALGORITHM

```
→ import mongoose

→ define connectDB function
   → try connecting to MongoDB using MONGO_URI
   → if connection succeeds:
       → log "MongoDB connected"
   → if connection fails:
       → log error
       → do not crash process (graceful failure)

→ export connectDB function
```

---

# `src/broker/borker.js`

### CONNECT TO MESSAGE BROKER ALGORITHM

```
→ import amqplib

→ maintain global connection and channel variables

→ define connect function
   → if connection already exists:
       → return existing connection
   → else:
       → connect to RabbitMQ using RABBIT_URL
       → create channel
       → store connection and channel
       → log success
   → on error:
       → log failure
```

---

### PUBLISH TO QUEUE ALGORITHM

```
→ accept queueName and data

→ if channel or connection not initialized:
     → call connect()

→ assert queue (durable)

→ convert data to JSON buffer

→ send message to queue

→ log queue name and payload
```

---

### SUBSCRIBE TO QUEUE ALGORITHM

```
→ accept queueName and callback

→ if channel or connection not initialized:
     → call connect()

→ assert queue (durable)

→ consume messages from queue
   → for each message:
       → parse JSON data
       → execute callback(data)
       → acknowledge message
```

---

# `src/middlewares/auth.middleware.js`

### ROLE-BASED AUTHENTICATION ALGORITHM

```
→ accept allowed roles (default: ['user'])

→ return middleware function

→ extract token from:
     → cookies.token OR
     → Authorization header (Bearer token)

→ if token not present:
     → return 401 Unauthorized

→ verify token using JWT_SECRET
   → if verification fails:
       → return 401 Invalid token

→ extract decoded user payload

→ check if decoded.role exists in allowed roles
   → if not:
       → return 403 Forbidden

→ attach decoded user to req.user

→ call next()
```

---

# `src/models/product.model.js`

### PRODUCT SCHEMA DESIGN ALGORITHM

```
→ define product schema with fields:
   → title (string, required)
   → description (string, optional)
   → price object:
       → amount (number, required)
       → currency (enum: USD, INR)
   → seller (ObjectId, required)
   → images array:
       → url
       → thumbnail
       → id
   → stock (number, default 0)

→ enable text index on:
   → title
   → description

→ export Product model
```

---

# `src/routes/product.routes.js`

### ROUTE REGISTRATION ALGORITHM

```
→ import express router
→ configure multer with memory storage

→ POST /api/products
   → authenticate roles: admin, seller
   → parse multipart images (max 5)
   → validate request body
   → call createProduct controller

→ GET /api/products
   → public access
   → call getProducts controller

→ PATCH /api/products/:id
   → authenticate seller
   → call updateProduct controller

→ DELETE /api/products/:id
   → authenticate seller
   → call deleteProduct controller

→ GET /api/products/seller
   → authenticate seller
   → call getProductsBySeller controller

→ GET /api/products/:id
   → public access
   → call getProductById controller
```

---

# `src/controllers/product.controller.js`

---

### CREATE PRODUCT ALGORITHM

```
→ extract title, description, priceAmount, priceCurrency from req.body
→ extract sellerId from req.user.id

→ construct price object:
   → convert priceAmount to Number
   → assign currency (default INR)

→ process uploaded files:
   → for each file buffer:
       → upload to ImageKit
       → collect returned image metadata

→ create product in database with:
   → title
   → description
   → price
   → seller
   → images

→ publish PRODUCT_CREATED event to:
   → seller dashboard queue
   → notification queue (email + productId)

→ return 201 Created with product data

→ on error:
   → log error
   → return 500 Internal Server Error
```

---

### GET PRODUCTS ALGORITHM

```
→ extract query params:
   → q (search)
   → minprice
   → maxprice
   → skip
   → limit

→ initialize empty filter object

→ if search query exists:
   → apply $text search

→ if minprice exists:
   → apply $gte filter on price.amount

→ if maxprice exists:
   → apply $lte filter on price.amount

→ query database:
   → apply filters
   → apply pagination
   → cap limit at 20

→ return 200 with product list
```

---

### GET PRODUCT BY ID ALGORITHM

```
→ extract product id from params

→ validate ObjectId
   → if invalid:
       → return 400

→ find product by id

→ if not found:
   → return 404

→ return 200 with product data
```

---

### UPDATE PRODUCT ALGORITHM

```
→ extract product id

→ validate ObjectId
   → if invalid:
       → return 400

→ fetch product from database

→ if not found:
   → return 404

→ verify ownership:
   → if product.seller !== req.user.id:
       → return 403 Forbidden

→ define allowed update fields:
   → title
   → description
   → price

→ iterate over request body keys
   → update allowed fields only
   → handle price.amount and price.currency separately

→ save updated product

→ return 200 with updated product
```

---

### DELETE PRODUCT ALGORITHM

```
→ extract product id

→ validate ObjectId
   → if invalid:
       → return 400

→ find product

→ if not found:
   → return 404

→ verify ownership
   → if not owner:
       → return 403

→ delete product from database

→ return 200 with success message
```

---

### GET PRODUCTS BY SELLER ALGORITHM

```
→ extract seller from req.user

→ extract pagination params

→ query products where:
   → seller equals req.user.id

→ apply pagination
→ limit max results to 20

→ return 200 with seller's products
```

---

# `src/services/imagekit.service.js`

### IMAGE UPLOAD ALGORITHM

```
→ accept image buffer and optional folder

→ generate unique filename using UUID

→ upload buffer to ImageKit:
   → file
   → fileName
   → folder

→ extract upload response

→ return standardized object:
   → url
   → thumbnailUrl (fallback to url)
   → fileId
```

---

# `src/validators/product.validators.js`

### CREATE PRODUCT VALIDATION ALGORITHM

```
→ validate title:
   → must be string
   → must not be empty

→ validate description (optional):
   → must be string
   → max length 500

→ validate priceAmount:
   → must exist
   → must be number > 0

→ validate priceCurrency (optional):
   → must be USD or INR

→ collect validation errors

→ if errors exist:
   → return 400 with error list

→ else:
   → call next()
```

---

# `tests/fixtures/sample.jpg`

### TEST FIXTURE USAGE ALGORITHM

```
→ store a dummy binary file
→ file is not opened or parsed
→ file is streamed as multipart/form-data
→ used only to simulate image upload in tests
→ content does not matter, only presence matters
```

---

# `tests/product.post.test.js`

### TEST SUITE: CREATE PRODUCT (POST /api/products)

---

### GLOBAL TEST SETUP ALGORITHM

```
→ create in-memory MongoDB server
→ set MONGO_URI to memory server URI
→ set JWT_SECRET for test environment
→ connect mongoose to in-memory database
```

---

### GLOBAL TEST TEARDOWN ALGORITHM

```
→ drop test database
→ close mongoose connection
→ stop in-memory MongoDB server
```

---

### AFTER EACH TEST CLEANUP ALGORITHM

```
→ fetch all MongoDB collections
→ delete all documents from each collection
```

---

### TEST: CREATE PRODUCT WITH IMAGE UPLOAD

```
→ generate JWT token with:
   → random user id
   → role = seller

→ send POST /api/products request
   → attach Authorization Bearer token
   → attach form fields:
       → title
       → description
       → priceAmount
       → priceCurrency
   → attach image file (sample.jpg)

→ expect response status = 201
→ expect response body contains:
   → product title
   → numeric price amount
   → images array length = 1
   → image URL contains mocked ImageKit URL
```

---

### TEST: VALIDATION FAILURE WHEN REQUIRED FIELDS MISSING

```
→ generate JWT token with seller role

→ send POST /api/products request
   → only provide title
   → omit priceAmount

→ expect response status = 400
→ expect validation error response
```

---

# `tests/product.get.test.js`

### TEST SUITE: LIST PRODUCTS (GET /api/products)

---

### SETUP ALGORITHM

```
→ start in-memory MongoDB
→ connect mongoose
→ sync text indexes for Product model
```

---

### TEST: EMPTY PRODUCT LIST

```
→ ensure no products exist

→ send GET /api/products

→ expect status = 200
→ expect data to be an empty array
```

---

### TEST: RETURN ALL PRODUCTS

```
→ insert multiple products into database

→ send GET /api/products

→ expect status = 200
→ expect returned list length equals inserted count
```

---

### TEST: TEXT SEARCH USING q PARAMETER

```
→ insert products with different titles/descriptions

→ send GET /api/products?q=shirt

→ expect status = 200
→ expect only matching products returned
→ ensure unrelated products excluded
```

---

### TEST: PRICE RANGE FILTERING

```
→ insert products with different price amounts

→ send GET with:
   → minprice only
→ expect only products >= minprice

→ send GET with:
   → maxprice only
→ expect only products <= maxprice

→ send GET with:
   → minprice + maxprice
→ expect products within range
```

---

### TEST: PAGINATION SUPPORT

```
→ insert multiple products

→ send GET with limit=2
→ expect 2 products

→ send GET with skip=2, limit=2
→ expect next 2 products

→ send GET with skip beyond count
→ expect remaining products only
```

---

# `tests/product.getById.test.js`

### TEST SUITE: GET PRODUCT BY ID

---

### TEST: INVALID OBJECT ID

```
→ send GET /api/products/{invalid-id}

→ expect status = 400
→ expect error message indicating invalid product id
```

---

### TEST: PRODUCT NOT FOUND

```
→ generate valid ObjectId that does not exist

→ send GET /api/products/{id}

→ expect status = 404
→ expect not found message
```

---

### TEST: PRODUCT FOUND

```
→ create product in database

→ send GET /api/products/{product-id}

→ expect status = 200
→ expect returned product id matches
→ expect correct product title
```

---

# `tests/product.patch.test.js`

### TEST SUITE: UPDATE PRODUCT (PATCH /api/products/:id)

---

### TEST: UNAUTHENTICATED REQUEST

```
→ create product

→ send PATCH request without token

→ expect status = 401
```

---

### TEST: NON-SELLER ROLE

```
→ create product
→ generate JWT with role = user

→ send PATCH request

→ expect status = 403
```

---

### TEST: INVALID PRODUCT ID

```
→ generate seller JWT

→ send PATCH with invalid product id

→ expect status = 400
```

---

### TEST: PRODUCT NOT FOUND

```
→ generate valid ObjectId not in database

→ send PATCH request

→ expect status = 404
```

---

### TEST: FORBIDDEN UPDATE (WRONG SELLER)

```
→ create product owned by seller B
→ authenticate as seller A

→ send PATCH request

→ expect status = 403
```

---

### TEST: SUCCESSFUL UPDATE

```
→ create product owned by authenticated seller

→ send PATCH request with:
   → new title
   → new description
   → new price object

→ expect status = 200
→ expect updated fields reflect new values
```

---

# `tests/product.delete.test.js`

### TEST SUITE: DELETE PRODUCT (DELETE /api/products/:id)

---

### TEST: UNAUTHENTICATED DELETE

```
→ create product

→ send DELETE request without token

→ expect status = 401
```

---

### TEST: NON-SELLER ROLE

```
→ create product
→ authenticate with role = user

→ send DELETE request

→ expect status = 403
```

---

### TEST: INVALID PRODUCT ID

```
→ authenticate as seller

→ send DELETE with invalid id

→ expect status = 400
```

---

### TEST: PRODUCT NOT FOUND

```
→ authenticate as seller
→ send DELETE with non-existing id

→ expect status = 404
```

---

### TEST: FORBIDDEN DELETE (WRONG SELLER)

```
→ create product owned by seller B
→ authenticate as seller A

→ send DELETE request

→ expect status = 403
```

---

### TEST: SUCCESSFUL DELETE

```
→ create product owned by authenticated seller

→ send DELETE request

→ expect status = 200
→ verify product no longer exists in database
```

---

# `tests/product.seller.get.test.js`

### TEST SUITE: GET PRODUCTS BY SELLER

---

### TEST: UNAUTHENTICATED ACCESS

```
→ send GET /api/products/seller without token

→ expect status = 401
```

---

### TEST: NON-SELLER ROLE

```
→ authenticate with role = user

→ send GET /api/products/seller

→ expect status = 403
```

---

### TEST: RETURN ONLY AUTHENTICATED SELLER PRODUCTS

```
→ create products for seller A
→ create products for seller B

→ authenticate as seller A

→ send GET /api/products/seller

→ expect only seller A products returned
```

---

### TEST: PAGINATION FOR SELLER PRODUCTS

```
→ create multiple products for seller

→ send GET with limit
→ expect limited results

→ send GET with skip + limit
→ expect next batch of products
```

---