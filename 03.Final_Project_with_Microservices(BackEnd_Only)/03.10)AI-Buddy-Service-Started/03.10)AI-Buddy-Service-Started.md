.
â”œâ”€â”€ .dockerignore
â”œâ”€â”€ dockerfile
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ server.js
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ agent
â”‚   â”‚   â”œâ”€â”€ agent.js
â”‚   â”‚   â”œâ”€â”€ tools.js
â”‚   â”œâ”€â”€ app.js
â”‚   â”œâ”€â”€ sockets
â”‚   â”‚   â”œâ”€â”€ socket.server.js
â”œâ”€â”€ tree.txt

---

# ğŸ“ `src/agent/agent.js`

## AGENT INITIALIZATION ALGORITHM

```
â†’ Import StateGraph and MessagesAnnotation for state-based conversation flow
â†’ Import Gemini chat model wrapper
â†’ Import message types (Human, AI, Tool)
â†’ Import tool registry
â†’ Initialize Gemini model with:
   - model: gemini-2.0-flash
   - temperature: 0.5
â†’ Create a StateGraph using MessagesAnnotation
â†’ Compile the graph into a runnable agent
â†’ Export agent
```

---

## CHAT NODE ALGORITHM

```
CHAT NODE:
â†’ Receive current conversation state
â†’ Invoke Gemini model with:
   - full message history
   - allowed tools: searchProduct, addProductToCart
â†’ Gemini decides:
   - either produce a normal text response
   - or produce tool_calls
â†’ Wrap model output into AIMessage:
   - content = response text
   - tool_calls = response tool calls (if any)
â†’ Append AIMessage to state.messages
â†’ Return updated state
```

---

## TOOLS NODE ALGORITHM

```
TOOLS NODE:
â†’ Get last message from state.messages
â†’ Extract tool_calls from last AIMessage
â†’ For each tool_call:
   â†’ Find tool by name from tools registry
   â†’ If tool not found:
        â†’ throw error
   â†’ Extract arguments from tool_call
   â†’ Inject auth token from graph metadata
   â†’ Execute tool function
   â†’ Wrap tool result into ToolMessage
â†’ Append all ToolMessages to state.messages
â†’ Return updated state
```

---

## CONDITIONAL TRANSITION ALGORITHM

```
AFTER CHAT NODE:
â†’ Check last AIMessage
â†’ If tool_calls exist AND length > 0:
     â†’ Transition to TOOLS node
â†’ Else:
     â†’ End execution
```

---

## GRAPH FLOW ALGORITHM

```
GRAPH FLOW:
â†’ __start__ â†’ chat
â†’ chat â†’ tools (if tool_calls present)
â†’ tools â†’ chat
â†’ chat â†’ __end__ (if no tool_calls)
```

---

# ğŸ“ `src/agent/tools.js`

## SEARCH PRODUCT TOOL ALGORITHM

```
SEARCH PRODUCT TOOL:
â†’ Take input:
   - query (string)
   - token (JWT)
â†’ Log tool invocation
â†’ Call Product Service API:
   - GET /api/products?q=query
   - Authorization: Bearer token
â†’ Receive product list response
â†’ Convert response to JSON string
â†’ Return product search result
```

---

## ADD PRODUCT TO CART TOOL ALGORITHM

```
ADD PRODUCT TO CART TOOL:
â†’ Take input:
   - productId
   - qty (default: 1)
   - token (JWT)
â†’ Call Cart Service API:
   - POST /api/cart/items
   - body: { productId, qty }
   - Authorization: Bearer token
â†’ Confirm successful addition
â†’ Return success message string
```

---

## TOOL REGISTRATION ALGORITHM

```
TOOL REGISTRATION:
â†’ Wrap each tool using LangChain `tool()` abstraction
â†’ Define:
   - tool name
   - description (for LLM reasoning)
   - input validation schema using Zod
â†’ Export all tools as a registry object
```

---

# ğŸ“ `src/app.js`

## EXPRESS APP INITIALIZATION ALGORITHM

```
APP INITIALIZATION:
â†’ Create Express application instance
â†’ Register base health route (/)
â†’ On GET /:
   â†’ Return HTTP 200
   â†’ Respond with JSON: { message: "AI service is running" }
â†’ Export app for server bootstrap
```

---

# ğŸ“ `src/sockets/socket.server.js`

## SOCKET SERVER INITIALIZATION ALGORITHM

```
SOCKET SERVER SETUP:
â†’ Initialize Socket.IO server on given HTTP server
â†’ Set custom socket path
â†’ Attach authentication middleware
â†’ Handle client connections
```

---

## SOCKET AUTH MIDDLEWARE ALGORITHM

```
SOCKET AUTH:
â†’ Read cookies from socket handshake headers
â†’ Parse cookies
â†’ Extract token
â†’ If token missing:
     â†’ Reject connection
â†’ Verify JWT using JWT_SECRET
â†’ If verification fails:
     â†’ Reject connection
â†’ Attach decoded user info to socket
â†’ Attach raw token to socket
â†’ Allow connection
```

---

## SOCKET MESSAGE HANDLING ALGORITHM

```
ON CLIENT MESSAGE:
â†’ Receive user message string
â†’ Invoke AI agent with:
   - messages: [ user message ]
   - metadata: { token }
â†’ Agent internally:
   - reasons
   - calls tools if required
   - loops until final response
â†’ Extract last AIMessage from agent response
â†’ Emit final message back to client
```

---

## COMPLETE REAL-TIME AI FLOW (HIGH LEVEL)

```
USER â†’ Socket Message
â†’ JWT Authentication
â†’ Agent Invocation
â†’ Gemini Reasoning
â†’ Tool Calls (if needed)
â†’ Backend APIs
â†’ Tool Results
â†’ Final AI Response
â†’ Socket Emit to Client
```

---