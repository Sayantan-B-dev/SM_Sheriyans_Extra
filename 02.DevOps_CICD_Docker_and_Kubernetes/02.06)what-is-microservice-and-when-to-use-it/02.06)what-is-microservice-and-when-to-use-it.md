# **Monolith vs Microservices: Complete Practical Guide**  
*When to Use Each, Scaling, Load Testing & Migration*

---

## **1. Understanding Architecture Patterns**

### **Monolithic Architecture**
**What it is**: Single, unified codebase where all components run as one service.

**Example - E-commerce Monolith:**
```javascript
// One codebase handling everything
const express = require('express');
const app = express();

// All features in one app
app.get('/products', (req, res) => { /* Get products */ });
app.get('/orders', (req, res) => { /* Get orders */ });
app.get('/users', (req, res) => { /* Get users */ });
app.post('/payment', (req, res) => { /* Process payment */ });

app.listen(3000);
```

### **Microservices Architecture**
**What it is**: Multiple independent services, each handling specific business capability.

**Example - E-commerce Microservices:**
```javascript
// Product Service (port 3001)
const productApp = express();
productApp.get('/products', (req, res) => { /* Only products */ });
productApp.listen(3001);

// Order Service (port 3002)
const orderApp = express();
orderApp.get('/orders', (req, res) => { /* Only orders */ });
orderApp.listen(3002);

// User Service (port 3003)
const userApp = express();
userApp.get('/users', (req, res) => { /* Only users */ });
userApp.listen(3003);
```

---

## **2. Scaling Types in Monolith**

### **Vertical Scaling (Scale Up)**
**What**: Increase resources of a single server (more CPU, RAM)

**How**: Upgrade from t2.micro → t2.large → t2.xlarge

**Code Impact**: None - same code runs on bigger machine

**Limits**: 
- Maximum instance size limits
- Single point of failure
- Cost grows exponentially

### **Horizontal Scaling (Scale Out)**
**What**: Add more identical servers behind load balancer

**How**: Launch multiple EC2 instances, use ALB to distribute traffic

**Code Requirements**: 
- Must be stateless (no session storage on server)
- Shared database needed
- Session management via Redis/ElastiCache

**Example Setup:**
```
Internet → Load Balancer → [Monolith Server 1, Monolith Server 2, Monolith Server 3]
```

---

## **3. Load Testing with Autocannon**

### **Step 1: Install Autocannon**
```bash
npm install -g autocannon
# or for project use
npm install autocannon --save-dev
```

### **Step 2: Load Test Script Example**
```javascript
const autocannon = require('autocannon');

// Array of API endpoints to test
const apis = [
  'http://localhost:3000/products',
  'http://localhost:3000/orders', 
  'http://localhost:3000/users',
  'http://localhost:3000/payment'
];

function runTest(url) {
  return new Promise((resolve) => {
    const instance = autocannon({
      url: url,
      connections: 100,     // Number of concurrent connections
      duration: 30,         // Test duration in seconds
      pipelining: 10        // Number of pipelined requests per connection
    }, (err, result) => {
      if (err) {
        console.error(`Error testing ${url}:`, err);
        resolve(null);
      } else {
        resolve({
          url: url,
          totalRequests: result.requests.total,
          totalErrors: result.errors,
          latencyAvg: result.latency.average
        });
      }
    });

    // Optional: Track progress
    autocannon.track(instance, { renderProgressBar: true });
    
    instance.on('response', (client, statusCode) => {
      // Optional: Log responses
    });
    
    instance.on('done', (result) => {
      // Optional: Process results
    });
  });
}

async function main() {
  console.log('Starting load tests...\n');
  
  const results = [];
  
  // Test each API endpoint
  for (const api of apis) {
    console.log(`Testing: ${api}`);
    const result = await runTest(api);
    if (result) results.push(result);
  }
  
  // Display results
  console.log('\n=== LOAD TEST RESULTS ===');
  let totalSuccess = 0;
  let totalErrors = 0;
  
  results.forEach((res, index) => {
    console.log(`\n${index + 1}. ${res.url}`);
    console.log(`   Requests: ${res.totalRequests.toLocaleString()}`);
    console.log(`   Errors: ${res.totalErrors}`);
    console.log(`   Avg Latency: ${res.latencyAvg}ms`);
    
    totalSuccess += res.totalRequests;
    totalErrors += res.totalErrors;
  });
  
  console.log('\n=== SUMMARY ===');
  console.log(`Total Successful Requests: ${totalSuccess.toLocaleString()}`);
  console.log(`Total Errors: ${totalErrors}`);
  console.log(`Success Rate: ${((totalSuccess / (totalSuccess + totalErrors)) * 100).toFixed(2)}%`);
}

// Run tests
main().catch(console.error);
```

### **Step 3: Run the Test**
```bash
# Start your monolith server first
node monolith-server.js

# Then run the load test
node load-test.js
```

---

## **4. Dividing Monolith into Microservices**

### **Example Monolith Structure:**
```javascript
// monolith.js (port 3000)
const express = require('express');
const app = express();

// Mixed concerns in one file
app.get('/about', (req, res) => { res.send('About Us'); });
app.get('/contact', (req, res) => { res.send('Contact Page'); });
app.get('/products', (req, res) => { res.send('Products'); });

app.listen(3000);
```

### **Step 1: Split into Separate Services**

**Service 1 - About Service:**
```javascript
// about-service.js (port 3001)
const express = require('express');
const app = express();

app.get('/about', (req, res) => { 
  res.send('About Us - Microservice'); 
});

app.listen(3001);
console.log('About Service running on port 3001');
```

**Service 2 - Contact Service:**
```javascript
// contact-service.js (port 3002)
const express = require('express');
const app = express();

app.get('/contact', (req, res) => { 
  res.send('Contact Page - Microservice'); 
});

app.listen(3002);
console.log('Contact Service running on port 3002');
```

**Service 3 - Main Service:**
```javascript
// main-service.js (port 3000)
const express = require('express');
const app = express();

app.get('/', (req, res) => { 
  res.send('Home Page'); 
});

app.get('/products', (req, res) => { 
  res.send('Products - Microservice'); 
});

app.listen(3000);
console.log('Main Service running on port 3000');
```

---

## **5. Running Microservices with PM2**

### **Step 1: Install PM2**
```bash
npm install pm2 -g
```

### **Step 2: Start All Services**
```bash
# Start each service as separate process
pm2 start about-service.js --name "about-service"
pm2 start contact-service.js --name "contact-service"  
pm2 start main-service.js --name "main-service"

# Alternative: Use ecosystem file
pm2 ecosystem
# Then edit ecosystem.config.js and run:
# pm2 start ecosystem.config.js
```

### **Step 3: Manage Services**
```bash
# View all running services
pm2 list

# Monitor logs
pm2 logs

# View specific service logs
pm2 logs about-service

# Stop a service
pm2 stop about-service

# Restart all
pm2 restart all

# Save current processes (auto-start on reboot)
pm2 save
pm2 startup
```

### **Step 4: Load Test Microservices**
Update your load test array:
```javascript
const apis = [
  'http://localhost:3000/',           // Main service
  'http://localhost:3000/products',   // Main service
  'http://localhost:3001/about',      // About service
  'http://localhost:3002/contact'     // Contact service
];
```

**Expected Results**:
- **Higher success rate**: Each service handles specific load
- **Better resource utilization**: CPU/RAM per service
- **Independent scaling**: Can scale busy services only

---

## **6. When to Use Monolith**

### **✅ USE MONOLITH WHEN:**
1. **Small Team** (2-5 developers)
2. **Simple Application** (CRUD operations, basic features)
3. **Quick Time-to-Market** needed
4. **Limited Budget** (lower infrastructure complexity)
5. **Early Startup Phase** (validating product idea)

### **Examples Suited for Monolith:**
- **Blog platform** (WordPress style)
- **Small e-commerce store**
- **Internal company tools**
- **MVP (Minimum Viable Product)**
- **University project applications**

---

## **7. When NOT to Use Monolith**

### **❌ AVOID MONOLITH WHEN:**
1. **Team Size > 10 developers** (merge conflicts, coordination issues)
2. **Multiple Technology Stacks needed** (different parts need different tech)
3. **Independent Scaling Requirements** (some features get more traffic)
4. **Frequent Deployments needed** (one change requires full redeploy)
5. **High Availability Critical** (monolith failure = entire app down)

### **Examples NOT Suited for Monolith:**
- **Netflix/Spotify** (millions of users, multiple features)
- **Uber/Airbnb** (different services: maps, payments, messaging)
- **Banking Systems** (need isolated, secure services)
- **Large E-commerce** (Black Friday traffic spikes)
- **Microservices by nature** (IoT platforms, SaaS with modules)

---

## **8. When to Use Microservices**

### **✅ USE MICROSERVICES WHEN:**
1. **Large Development Team** (>10 developers, multiple teams)
2. **Different Technology Needs** (Python for ML, Node.js for API, Java for backend)
3. **Independent Scaling Needed** (authentication vs video processing)
4. **High Availability Required** (99.99% uptime)
5. **Continuous Deployment** (deploy one service without affecting others)

### **Examples Suited for Microservices:**
- **E-commerce Platform**:
  - Product Service (Node.js)
  - Payment Service (Java - secure)
  - Recommendation Service (Python - ML)
  - Notification Service (Go - fast)
  
- **Social Media App**:
  - User Profile Service
  - Feed Service  
  - Messaging Service
  - Media Upload Service

- **Banking Application**:
  - Account Service
  - Transaction Service
  - Fraud Detection Service
  - Notification Service

---

## **9. When NOT to Use Microservices**

### **❌ AVOID MICROSERVICES WHEN:**
1. **Small Team** (<5 developers - too much overhead)
2. **Simple Application** (CRUD app - overengineering)
3. **Tight Budget** (higher infrastructure costs)
4. **Short Timeline** (complex setup takes time)
5. **Team Not Experienced** (steep learning curve)

### **Problems with Premature Microservices:**
```javascript
// PROBLEM: Over-engineered simple app
// Instead of one file, now you have:

1. user-service/           (Handles login)
2. product-service/        (Handles products)  
3. order-service/         (Handles orders)
4. email-service/         (Sends emails)
5. api-gateway/           (Routes requests)
6. service-discovery/     (Finds services)

// Result: 6x more code, deployment complexity, network latency
```

---

## **10. Migration Strategy: When to Split Monolith**

### **Signs It's Time to Split:**
1. **Deployment Pain**: Changing one line requires full redeploy
2. **Scaling Issues**: Need to scale entire app for one busy feature
3. **Team Blockers**: Multiple teams waiting for same codebase
4. **Technology Lock-in**: Can't use right tool for specific job
5. **Testing Takes Hours**: Unit tests run for 1+ hours

### **How to Split Safely:**
```javascript
// Phase 1: Identify bounded context
Original: GET /api/user-orders
Split to:
1. GET /users/:id     (User Service)
2. GET /orders?userId=:id  (Order Service)

// Phase 2: Create Strangler Fig Pattern
app.get('/api/user-orders', (req, res) => {
  // New: Call both microservices
  // Old: Monolith logic (gradually replace)
});

// Phase 3: Move traffic gradually
Week 1: 10% traffic to microservices
Week 2: 50% traffic to microservices  
Week 4: 100% traffic to microservices
```

---

## **11. Quick Decision Flowchart**

```
Start → New Project?
    ├── Small Team? (2-5) → Yes → MONOLITH
    ├── Simple CRUD App? → Yes → MONOLITH  
    ├── Need Fast MVP? → Yes → MONOLITH
    └── Otherwise → Consider MICROSERVICES if:
        - Large team (>10)
        - Need different tech stacks
        - Independent scaling required
        - High availability critical
```

---

## **12. Cost Comparison**

### **Monolith Costs:**
```javascript
// Development: Lower
// Infrastructure: 
//   - Fewer servers (vertical scaling)
//   - Simpler deployment
//   - Less monitoring needed
// Total: $$$ (lower)

// Example: Blog Platform
1x EC2 t3.large = $60/month
1x RDS db.t3.medium = $70/month
Total: ~$130/month
```

### **Microservices Costs:**
```javascript
// Development: Higher (more code, coordination)
// Infrastructure:
//   - More servers (horizontal scaling)
//   - Load balancers
//   - Service mesh (optional)
//   - Monitoring tools
// Total: $$$$$ (higher)

// Example: E-commerce Microservices
4x ECS tasks = $80/month
1x ALB = $20/month  
1x ElastiCache = $50/month
3x RDS instances = $210/month
Total: ~$360/month
```

---

## **13. Practical Exercise**

### **Try This: Build Both Ways**
1. **Build Monolith** (30 minutes):
   ```bash
   # Create one Express app with:
   # - /users (GET, POST)
   # - /products (GET, POST) 
   # - /orders (GET, POST)
   # All in one file, one database
   ```

2. **Build Microservices** (1 hour):
   ```bash
   # Create three separate services:
   # Service 1: User Service (port 3001)
   # Service 2: Product Service (port 3002)
   # Service 3: Order Service (port 3003)
   # Each with own database connection
   ```

3. **Compare**:
   - Development time
   - Code complexity  
   - Testing effort
   - Deployment steps

---

**Key Takeaway**: Start with monolith for simplicity, split to microservices when you have clear reasons. Don't use microservices just because they're trendy - the complexity cost is real. Choose based on your team size, application complexity, and scaling needs, not hype.