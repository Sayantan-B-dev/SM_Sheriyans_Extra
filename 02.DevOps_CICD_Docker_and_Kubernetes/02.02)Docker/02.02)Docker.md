# **Docker on AWS: Containerization Guide**  
*Why Docker? How to Containerize a Node.js Application*

---

## **1. The Problem: Direct EC2 Deployment Challenges**

### **Direct EC2 Setup Issues:**
1. **Environment Inconsistency**  
   - "Works on my machine" problem: Node.js versions, system libraries, and OS differences between local development and EC2.

2. **Manual Configuration Drift**  
   - Every new EC2 instance requires repeating: `apt update`, `Node.js installation`, `dependency installation`, `environment variable setup`.

3. **Resource Inefficiency**  
   - Running multiple applications on one EC2 instance leads to dependency conflicts and resource competition.

4. **Scaling Complexity**  
   - To scale, you must launch identical EC2 instances → manual replication or complex automation scripts.

5. **Security Updates**  
   - OS updates require SSH into each instance individually.

---

## **2. Docker: The Solution**

### **What is Docker?**
Docker is a **containerization platform** that packages applications and their dependencies into standardized, portable units called **containers**.

### **Key Benefits:**
- **Consistency**: Same environment everywhere (development, testing, production)
- **Isolation**: Each app runs in its own container with isolated dependencies
- **Portability**: Run anywhere (EC2, laptop, other cloud providers)
- **Efficiency**: Multiple containers on one EC2 instance with minimal overhead
- **Version Control**: Track changes to your application environment via Dockerfile

### **Analogy:**
- **EC2 Instance** = Apartment building  
- **Docker Container** = Self-contained studio apartment with all furniture/appliances  
- **Docker Image** = Blueprint for the studio apartment

---

## **3. Docker Architecture on AWS**

### **Docker Components:**
1. **Docker Image**  
   - Read-only template with application code + runtime + dependencies
   - Built from a **Dockerfile** (recipe)

2. **Docker Container**  
   - Running instance of an image

3. **Dockerfile**  
   - Text document with commands to build the image

4. **Docker Hub/Registry**  
   - Storage for Docker images (AWS has **ECR - Elastic Container Registry**)

### **AWS Services for Docker:**
- **ECS (Elastic Container Service)**: Run Docker containers on AWS
- **Fargate**: Serverless containers (no EC2 management)
- **EKS (Elastic Kubernetes Service)**: For Kubernetes orchestration

---

## **4. Installation: Docker Desktop**

### **For Windows/Mac:**
1. **Download Docker Desktop**  
   - Visit [docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
   
2. **Installation Steps:**
   - **Windows**: Run installer → Enable WSL 2 feature if prompted → Restart
   - **Mac**: Drag Docker to Applications folder → Open → Grant permissions
   
3. **Verification:**
   ```bash
   docker --version
   docker run hello-world
   ```

### **For Linux (Ubuntu on EC2):**
```bash
# Update packages
sudo apt update

# Install prerequisites
sudo apt install apt-transport-https ca-certificates curl software-properties-common

# Add Docker GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Add Docker repository
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Install Docker
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io

# Verify installation
sudo docker --version

# Add user to docker group (to run without sudo)
sudo usermod -aG docker $USER
# Log out and back in for changes to take effect
```

---

## **5. Creating a Dockerfile: Step-by-Step Explanation**

### **What is a Dockerfile?**
A text file with sequential instructions to build a Docker image.

### **Sample Dockerfile for Node.js Application:**
```dockerfile
# Layer 1: Base Image
FROM node:18-alpine
# Why: Starts with Linux (Alpine) + Node.js 18 pre-installed
# Alpine = lightweight Linux distribution (~5MB)

# Layer 2: Working Directory
WORKDIR /app
# Why: Creates /app directory in container and sets as default location

# Layer 3: Copy Dependency Files
COPY package*.json ./
# Why: Copy both package.json AND package-lock.json
# Separating copy of package files allows Docker cache optimization

# Layer 4: Install Dependencies
RUN npm install
# Why: Installs all dependencies inside container
# Creates node_modules folder in /app

# Layer 5: Copy Application Code
COPY server.js ./
# Why: Copy actual application code AFTER dependencies
# This layer changes frequently, so it's placed later

# Layer 6: Expose Port
EXPOSE 3000
# Why: Documents which port the container listens on
# Doesn't actually publish the port (done at runtime)

# Layer 7: Command to Run
CMD ["node", "server.js"]
# Why: Default command when container starts
# Only one CMD per Dockerfile
```

### **Dockerfile Best Practices:**
1. **Use specific versions** (not `node:latest`)
2. **Order matters**: Place frequently changing layers last
3. **Minimize layers**: Combine related commands
4. **Use .dockerignore** (like .gitignore for Docker builds):
   ```
   node_modules
   .git
   Dockerfile
   *.log
   ```

---

## **6. Building and Managing Docker Images**

### **Building an Image:**
```bash
# Navigate to directory containing Dockerfile
cd /path/to/project

# Build the image
docker build -t my-node-app:1.0 .
# -t: Tag/name the image (format: name:tag)
# . : Build context (current directory)

# List all images
docker images
# or
docker image ls
```

### **Image Layers Explained:**
Each instruction in Dockerfile creates a **layer**. Layers are cached, making subsequent builds faster.
```bash
# View image layers
docker history my-node-app:1.0
```

### **Tagging for ECR/AWS:**
```bash
# Tag for AWS ECR (Elastic Container Registry)
docker tag my-node-app:1.0 123456789012.dkr.ecr.region.amazonaws.com/my-node-app:1.0
```

---

## **7. Running Docker Containers**

### **Basic Container Operations:**
```bash
# Run container from image
docker run -d -p 3000:3000 --name my-app my-node-app:1.0
# -d: Detached mode (run in background)
# -p: Port mapping (host:container)
# --name: Name the container

# List running containers
docker ps

# List all containers (including stopped)
docker ps -a

# Stop container
docker stop my-app

# Start stopped container
docker start my-app

# Remove container
docker rm my-app

# View container logs
docker logs my-app

# Execute command in running container
docker exec -it my-app bash
# -it: Interactive terminal
```

---

## **8. Real-World Workflow: Development vs Production**

### **Development:**
```dockerfile
# Development Dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "run", "dev"]  # With hot-reload
```

### **Production:**
```dockerfile
# Production Dockerfile (Multi-stage build)
# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

# Stage 2: Run
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
USER node  # Non-root user for security
EXPOSE 3000
CMD ["node", "dist/server.js"]
```

---

## **9. Deploying to AWS ECS (Elastic Container Service)**

### **High-Level ECS Workflow:**
1. **Build Docker image** locally
2. **Push to ECR** (AWS Container Registry)
3. **Create ECS Task Definition** (Container blueprint)
4. **Create ECS Service** (Manages container instances)
5. **Configure Load Balancer** (If needed)

### **Commands to Push to ECR:**
```bash
# Authenticate Docker to ECR
aws ecr get-login-password --region region | docker login --username AWS --password-stdin 123456789012.dkr.ecr.region.amazonaws.com

# Tag image
docker tag my-app:latest 123456789012.dkr.ecr.region.amazonaws.com/my-app:latest

# Push to ECR
docker push 123456789012.dkr.ecr.region.amazonaws.com/my-app:latest
```

---

## **10. Comparison: EC2 vs Docker on EC2 vs ECS**

| Aspect | Direct EC2 | Docker on EC2 | ECS/Fargate |
|--------|------------|---------------|-------------|
| **Setup Time** | High (manual) | Medium (Docker setup) | Low (managed) |
| **Consistency** | Low | High (images) | High |
| **Scaling** | Manual/ASG | Manual/ASG | Auto-scaling |
| **Resource Use** | Inefficient | Efficient (containers) | Optimized |
| **Management** | OS + App | OS + Containers | Just App |
| **Cost** | Pay for EC2 | Pay for EC2 | Pay for vCPU/RAM |

---

## **11. Common Docker Commands Cheat Sheet**

```bash
# Image Management
docker build -t name:tag .          # Build image
docker image ls                     # List images
docker image rm name:tag            # Remove image
docker image prune                  # Remove unused images

# Container Management
docker run -d -p host:cont name:tag # Run container
docker ps                           # List running containers
docker stop container_id            # Stop container
docker start container_id           # Start container
docker rm container_id              # Remove container
docker container prune              # Remove stopped containers

# Debugging
docker logs container_id            # View logs
docker exec -it container_id sh     # Shell into container
docker stats                        # Resource usage
docker inspect container_id         # Detailed info

# System
docker system df                    # Disk usage
docker system prune -a              # Clean everything
```

---

## **12. Next Steps: Orchestration with ECS**

Once comfortable with Docker:
1. **Study Docker Compose** for multi-container apps
2. **Learn AWS ECR** for private image storage
3. **Explore ECS Task Definitions** (JSON config for containers)
4. **Implement CI/CD** with GitHub Actions/AWS CodePipeline
5. **Study Service Discovery** for container communication

---

**Key Takeaway**: Docker solves environment consistency problems and enables modern deployment patterns (CI/CD, microservices). Start with Docker on EC2, then migrate to ECS/Fargate for fully managed container orchestration.