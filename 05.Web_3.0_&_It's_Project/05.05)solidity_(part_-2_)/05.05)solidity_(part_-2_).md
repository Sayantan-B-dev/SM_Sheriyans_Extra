### `storage` and `memory` (data location modifiers)

**Where data lives**

* `storage` → blockchain state (persistent, expensive)
* `memory` → temporary (function scope, cheaper)
* `calldata` → read-only input data (cheapest, external only)

---

## `memory` vs `calldata`

| Aspect      | memory              | calldata           |
| ----------- | ------------------- | ------------------ |
| Mutability  | mutable             | **read-only**      |
| Lifetime    | function execution  | function execution |
| Gas         | higher              | **lowest**         |
| Used in     | public / internal   | **external only**  |
| Typical use | internal processing | function inputs    |

```solidity
function f(string memory s) public { }      // OK
function g(string calldata s) external { }  // OK
```

---

## Why `memory` is needed for non-primitive types

Non-primitive types:

* `string`
* `bytes`
* `array`
* `struct`

They are **reference types**, so Solidity must know **where** they live.

```solidity
function temp(string memory _name) public { }
```

Why required:

* Compiler must know allocation location
* Default is **not assumed** for reference types
* Primitive types (`uint`, `bool`, `address`) are copied by value → no location needed

❌ This causes error:

```solidity
function temp(string _name) public { } // Error: data location missing
```

---

## `storage` — when to use & when it errors

### Valid use

Used when you want a **reference to state variables**

```solidity
string public name;

function update() public {
    string storage ref = name;
    ref = "new"; // modifies state
}
```

### Common error cases

❌ Using `storage` with function parameters

```solidity
function bad(string storage s) public { } 
// Error: storage parameters not allowed
```

❌ Using `storage` for local non-state variables

```solidity
function bad() public {
    string storage s; // Error: no storage slot
}
```

### Rule

* `storage` → **only for state variables or references to them**
* Never for inputs
* Never standalone inside functions

---

## `memory` vs `storage` summary

* Want persistence → `storage`
* Temporary logic → `memory`
* External input, no modification → `calldata`

---

## Gatekeeper function (`modifier`)

A **modifier** is a **pre-execution guard**.

Used for:

* Access control
* Validation
* Reusability

---

## Example (owner-only access)

```solidity
address public owner;
uint public temp;

constructor() {
    owner = msg.sender;
}
```

### Modifier

```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "only owner can call the function");
    _;
}
```

### Protected function

```solidity
function setTemp() public onlyOwner {
    temp = 100;
}
```

---

## Why `_ ;` is required in modifier

`_;` = **execution insertion point**

Expanded form:

```solidity
require(msg.sender == owner);
temp = 100;
```

Without `_ ;`

* Function body **never runs**
* Modifier blocks execution permanently

You can place `_ ;` anywhere:

```solidity
modifier example() {
    // before
    _;
    // after
}
```

Used for:

* Pre-checks
* Post-execution logic
* Logging
* Fees

---

## Modifier execution order

```solidity
function f() public m1 m2 { }
```

Execution:

1. `m1` before
2. `m2` before
3. function body
4. `m2` after
5. `m1` after

---

## Key rules (exam-safe)

* Reference types **must** specify data location
* `calldata` is cheapest & read-only
* `storage` modifies blockchain state
* Modifiers control **who / when / how**
* `_ ;` is mandatory to allow function execution
