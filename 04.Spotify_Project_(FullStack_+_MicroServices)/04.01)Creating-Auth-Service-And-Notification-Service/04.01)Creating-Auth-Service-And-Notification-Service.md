
[i-piiyush ▶ spotify](`https://github.com/i-piiyush/spotify.git`)


```markdown
# 1. Auth Microservice Initial Setup
➡️ Create auth folder for auth microservice
➡️ npm init -y
➡️ npm i express mongoose dotenv cookie-parser jsonwebtoken bcryptjs express-validator morgan
➡️ Set type to module to use import statement
```

```markdown
# 2. Auth App Structure
➡️ Create auth-service/src/app.js
➡️ Import express, morgan, cookieParser and use them as middleware including urlencoded and export app
```

```markdown
# 3. Configuration Setup
➡️ Create auth-service/config/config.js
➡️ Import config from dotenv and call it...use a _config to export all credentials
➡️ Export _config
```

```markdown
# 4. Database Connection
➡️ Create auth-service/src/db/db.js
➡️ Import mongoose, config, make connectDB function with config.MONGO_URI
```

```markdown
# 5. Environment Variables
➡️ Create .env and use all variables there
```

```markdown
# 6. Server Entry Point
➡️ Create auth-service/server.js
➡️ Import app
➡️ Connect db
➡️ Listen to app
```

```markdown
# 7. Package Scripts
➡️ In package.json add dev and start script command
```

```markdown
# 8. User Model
➡️ Create auth-service/src/models/user.models.js
➡️ Import mongoose
➡️ Make userSchema with email, fullname(first and last name), password(with required: function(){return !this.googleId}), googleId, role with enum and default,
➡️ Create model and export it
```

```markdown
# 9. Auth Routes Setup
➡️ Create auth-service/src/routes/auth.routes.js
➡️ Import express then express.Router()
➡️ Export the router
```

```markdown
# 10. Route Integration
➡️ In app.js import the auth routes
➡️ And use it for the route like /api/auth
```

```markdown
# 11. JWT Secret
➡️ Create a jwt secret in env
```

```markdown
# 12. Auth Controller - Register
➡️ Create auth-service/src/controllers/auth.controller.js
➡️ Import userModel, jwt, bcrypt, config
➡️ Create a register function
➡️ Take stuff from req.body
➡️ Check if user already exists with findOne({email})
➡️ Hash password with bcrypt
➡️ Create a user with userModel with await
➡️ Create a token with jwt.sign with secret and expire
➡️ Save token in cookie
➡️ The res.status.json
```

```markdown
# 13. Route Controller Connection
➡️ In auth routes import * as authController
➡️ Router to /register with the controller
```

```markdown
# 14. Validation Middleware
➡️ Create auth-service/src/middlewares/validation.middleware.js
➡️ Import body and validationResult
➡️ Make validate function, errors with validationResult and if it's not empty send it as error array
➡️ Create registerUserValidationRules with email, password, fullname.firstname, fullname.lastname, then use the validate function
➡️ Export the registerUserValidationRules
```

```markdown
# 15. Validation Integration
➡️ Import the validate function to auth.routes.js and use validation in each routes
```

```markdown
# 16. Google Auth Setup Steps
➡️ Start implementing google authentication,
➡️ Go to google cloud console, create new project, in api and service and then auth consent, start, create a consent screen, go back to api..go to credential...
➡️ Use https://github.com/ankurdotio/Difference-Backend-video/tree/main/025-googleoauth this website for the steps
➡️ Add the http://localhost:3000/api/auth/google/callback to the authorized redirect URIs in clients
➡️ Grab the client id and client secret and put it in env and update config
```

```markdown
# 17. Google Auth Dependencies
➡️ npm install express passport passport-google-oauth20 jsonwebtoken dotenv
```

```markdown
# 18. Passport Configuration in App
➡️ In app.js import passport,
➡️ Import strategy as GoogleStrategy from passport-google-oauth20
➡️ app.use passport.initialize()
➡️ Import config
➡️ Use passport.use(new GoogleStrategy({
    clientID: config.CLIENT_ID,
    clientSecret: config.CLIENT_SECRET,
    callbackURL: 'api/auth/google/callback',
  }, (accessToken, refreshToken, profile, done) => {
    return done(null, profile);
  })); under this
```

```markdown
# 19. Google Auth Routes
➡️ In auth.routes.js
➡️ router.get(
    "/google",
    passport.authenticate("google", { scope: ["profile", "email"] })
  );
➡️ router.get(
    "/google/callback",
    passport.authenticate("google", { session: false }),
    googleAuthCallback
  );
➡️ Create these two
```

```markdown
# 20. Google Auth Callback Controller
➡️ Go back to auth.controller.js
➡️ Create googleAuthCallback function
➡️ Take req.user data
➡️ Check if user already exist with .findOne({
      $or:[
          {email:user.emails[0].value},
          {googleId:user.id}
      ]
    })
➡️ If user already exists: create a token save in cookie, return response with success
➡️ Else just create a new user, create token, set cookie and res.status.json
```

```markdown
# 21. Queue Architecture
➡️ Auth publishes to queue and notification service subscribes to queue
```

```markdown
# 22. Notification Service Setup
➡️ Create notification folder on the same level as auth service
➡️ npm init -y
➡️ npm i express mongoose dotenv cookie-parser jsonwebtoken bcryptjs express-validator morgan
➡️ Set type to module to use import statement
```

```markdown
# 23. Notification App Structure
➡️ Create notification-service/src/app.js
➡️ In app import express and express app
```

```markdown
# 24. Notification Server
➡️ Create notification-service/server.js
➡️ Import app, listen to app
```

```markdown
# 25. Notification Scripts
➡️ Use dev and start script in package.json
```

```markdown
# 26. Notification Utilities
➡️ Create notification-service/src/utils/email.js
➡️ Create notification-service/src/config/config.js
```

```markdown
# 27. Nodemailer Reference
➡️ Nodemailer documentation
➡️ `https://github.com/ankurdotio/Difference-Backend-video/tree/main/026-nodemailer`
```

```markdown
# 28. Google API Console Setup Part 1
➡️ Go to the Google API Console:
➡️ Navigate to the Google API Console.
➡️ Create a new project or select an existing one.
➡️ Enable Gmail API:
```

```markdown
# 29. Google API Console Setup Part 2
➡️ Go to the Library section.
➡️ Search for Gmail API and enable it.
➡️ Create OAuth2 Credentials:
```

```markdown
# 30. OAuth2 Credentials Creation
➡️ Go to the Credentials section.
➡️ Click on Create Credentials and choose OAuth 2.0 Client IDs.
➡️ Set the application type to Web application.
➡️ Under Authorized redirect URIs, add http://localhost and https://developers.google.com/oauthplayground (or your application's URL).
➡️ After creating, you'll get your ClientID and ClientSecret.
```

```markdown
# 31. Refresh Token Generation Part 1
➡️ Generating the Refresh Token Using OAuth 2.0 Playground
➡️ Access OAuth 2.0 Playground:
➡️ Open the OAuth 2.0 Playground in your web browser.
```

```markdown
# 32. Refresh Token Generation Part 2
➡️ Configure OAuth 2.0 Playground:
➡️ In the top-right corner, click on the gear icon (settings).
➡️ Under OAuth 2.0 endpoints, select Use your own OAuth credentials.
➡️ Enter your ClientID and ClientSecret obtained from the Google Cloud Console.
➡️ Set the Access type to Offline to obtain a refresh token.
```

```markdown
# 33. Scope Selection
➡️ Select Scopes:
➡️ In Step 1 on the left panel, select the appropriate scopes for your application. For Gmail, choose:
➡️ https://mail.google.com/
```

```markdown
# 34. API Authorization
➡️ Authorize APIs:
➡️ Click on Authorize APIs. You'll be redirected to a Google login page to authorize the application.
```

```markdown
# 35. Token Exchange
➡️ Exchange Authorization Code for Tokens:
➡️ After authorizing, you'll be redirected back to the OAuth Playground.
➡️ Click on Exchange authorization code for tokens. This will generate an access token and a refresh token.
```

```markdown
# 36. Save Refresh Token
➡️ Copy Refresh Token:
➡️ Your refresh token will appear under the response for Step 2. Copy it and use it in your .env file.
➡️ Installation
```

```markdown
# 37. Nodemailer Installation
➡️ Initialize a Node.js Project:
➡️ npm install nodemailer
```

```markdown
# 38. Google Verification Error Fix
➡️ If error `not completed the google verification process....error 403 access_denied` occurs
➡️ Go to audience in console and add test user
```

```markdown
# 39. OAuth2 Settings Configuration
➡️ In oauth2 settings use clientid and client secret
➡️ And copy the refresh token from step 2
```

```markdown
# 40. Notification Environment Variables
➡️ Create notification-service/.env
➡️ In env put secrets like mongouri, jwtsecret, clientid, clientSecret, Refresh token, email user
```

```markdown
# 41. Notification Config Setup
➡️ In config.js import config as dotenvConfig
➡️ dotenvConfig()
➡️ Add the env in _config object and export it
```

```markdown
# 42. Email Service Implementation
➡️ In email.js import config
➡️ Import nodemailer
➡️ Create a transporter with nodemailer.createTransport that has an object as parameter with service and auth in it
➡️ It communicates webserver to smtp
➡️ Create a sendEmail function that takes to, subject, text, html as parameter and uses transporter.sendMail with all those along with from parameter as object
➡️ Use try catch
➡️ Export sendEmail function
```

```markdown
# 43. Email Testing
➡️ In app.js import sendEmail
➡️ Use it to test
```

```markdown
# 44. Message Queue Dependencies
➡️ Go back to auth-service
➡️ npm i amqplib
```

```markdown
# 45. Queue Implementation Strategy
➡️ Need to implement the queue in between auth and notification service using rabbitMQ/message brokers
➡️ The benefit is all service are loosely coupled non-dependent of each other
```

```markdown
# 46. CloudAMQP Setup
➡️ Use cloudAMQP
➡️ Create an instance with closer region
➡️ And grab the AMQP url
```

```markdown
# 47. RabbitMQ Connection Setup
➡️ Create auth-service/src/broker/rabbit.js
➡️ Import amqp and config from config file
➡️ Make sure new rabbit uri is added in config.js and env
➡️ Create channel and connection using let
➡️ Create a connect function that uses amqp.connect as connection, make a channel with connection.createChannel
➡️ Export the function and import it in server.js and call it
```

```markdown
# 48. Publish to Queue Function
➡️ In the same rabbit.js file create a publishToQueue function that takes queueName and data as parameter
➡️ And it uses async methods
➡️ channel.assertQueue with queuename and durable true
➡️ channel.sendToQueue with queuename and Buffer.from json.stringify of data
```

```markdown
# 49. Publish in Auth Controller
➡️ In auth.controller.js import the publish to queue function
➡️ After creating token... publishToQueue with proper parameters and user data as one single object
```

```markdown
# 50. Testing Queue Publishing
➡️ Check in postman with proper post message to register path
➡️ And check the published data in cloudAMQP > lavinMQ and you'll see the queue there and data at the bottom
```

```markdown
# 51. Notification Service Queue Setup
➡️ Back to notification-service and paste broker folder from auth-service here, make sure rabbit mq uri is also in this .env
➡️ And in this rabbit.js create a new function with subscribeToQueue with parameters (queueName and callback)
➡️ And in function assertQueue with the queuename
➡️ channel.consume(queuename ,async(msg)=>{
  await callback(JSON.parse(msg.content.toString()))
  await channel.ack(msg)
})
```

```markdown
# 52. Listener File Creation
➡️ Create a new listener.js in the broker folder in notification service
➡️ Import the subscribeToQueue from rabbit.js here too
➡️ Import sendEmail from email.js too
➡️ Now create a new function startListener(){
  subscribeToQueue(to the same channel that the auth service publishing data to, in second parameter use an async function with msg parameter to extract userinfo and send a message with sendEmail function)
}
➡️ And export it
```

```markdown
# 53. Listener Integration
➡️ In server.js import connect from rabbit.js and startListener from listener.js
➡️ And just use it like connect().then(startListener)
```

---